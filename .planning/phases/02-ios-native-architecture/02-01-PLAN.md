---
phase: 02-ios-native-architecture
plan: 01
type: execute
depends_on: []
files_modified:
  - mobile/ios/Runner/Services/LocationTrackingService.swift
  - mobile/ios/Runner/Services/LocationTrackingServiceProtocol.swift
domain: ios-native
---

<objective>
Extract location tracking functionality from AppDelegate into a dedicated LocationTrackingService.

Purpose: Isolate CLLocationManager handling, permissions, and accuracy switching into a testable service with protocol-based interface.
Output: LocationTrackingService.swift with protocol, LocationTrackingServiceProtocol.swift for mocking.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@mobile/ios/Runner/AppDelegate.swift

**Phase 1 context:**
- Python and Flutter test infrastructure established
- No iOS native mocks created in Phase 1 (tests focused on API layer)
- This phase creates the service architecture that will enable iOS native testing later

**Extracting from AppDelegate.swift:**
- Lines 179-208: setupLocationManager(), setHighAccuracy(), setLowAccuracy()
- Lines 407-452: CLLocationManagerDelegate methods
- Lines 216-245: startMonitoring(), stopMonitoring() (location portions)

**Established patterns:**
- Swift: PascalCase files, camelCase functions, 4-space indent
- Protocol-based dependency injection for testability
- MARK comments for section organization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LocationTrackingServiceProtocol</name>
  <files>mobile/ios/Runner/Services/LocationTrackingServiceProtocol.swift</files>
  <action>
Create Services directory under Runner and add protocol file defining the interface:

```swift
import CoreLocation

protocol LocationTrackingServiceProtocol: AnyObject {
    var delegate: LocationTrackingServiceDelegate? { get set }
    var isMonitoring: Bool { get }
    var lastLocation: CLLocation? { get }

    func setupLocationManager()
    func startMonitoring()
    func stopMonitoring()
    func setHighAccuracy()
    func setLowAccuracy()
}

protocol LocationTrackingServiceDelegate: AnyObject {
    func locationService(_ service: LocationTrackingServiceProtocol, didUpdateLocation location: CLLocation)
    func locationService(_ service: LocationTrackingServiceProtocol, didFailWithError error: Error)
    func locationService(_ service: LocationTrackingServiceProtocol, didChangeAuthorization status: CLAuthorizationStatus)
}
```

Use `AnyObject` constraint for weak delegate references. Keep protocol minimal - only expose what AppDelegate currently needs.
  </action>
  <verify>File exists at mobile/ios/Runner/Services/LocationTrackingServiceProtocol.swift</verify>
  <done>Protocol file created with LocationTrackingServiceProtocol and LocationTrackingServiceDelegate definitions</done>
</task>

<task type="auto">
  <name>Task 2: Create LocationTrackingService implementation</name>
  <files>mobile/ios/Runner/Services/LocationTrackingService.swift</files>
  <action>
Extract location functionality from AppDelegate into new service class:

1. Move these methods from AppDelegate:
   - `setupLocationManager()` (lines 181-190)
   - `setHighAccuracy()` (lines 192-199)
   - `setLowAccuracy()` (lines 201-208)
   - CLLocationManagerDelegate methods (lines 409-452)

2. Service should:
   - Implement `LocationTrackingServiceProtocol`
   - Conform to `CLLocationManagerDelegate`
   - Own the `CLLocationManager` instance
   - Forward location updates via delegate pattern to avoid coupling
   - Handle authorization changes internally but notify via delegate
   - Store lastLocation for access by other components

3. Keep print statements for now (will be replaced with proper logging in Phase 6)

4. Do NOT remove code from AppDelegate yet - this task just creates the new service. Task 3 will wire it up.

Structure:
```swift
import CoreLocation

class LocationTrackingService: NSObject, LocationTrackingServiceProtocol, CLLocationManagerDelegate {
    // MARK: - Properties
    weak var delegate: LocationTrackingServiceDelegate?
    private var locationManager: CLLocationManager!
    private(set) var isMonitoring = false
    private(set) var lastLocation: CLLocation?

    // MARK: - Setup
    // ... extract setupLocationManager

    // MARK: - Monitoring Control
    // ... extract start/stop

    // MARK: - Accuracy Control
    // ... extract high/low accuracy

    // MARK: - CLLocationManagerDelegate
    // ... extract delegate methods
}
```
  </action>
  <verify>File compiles - run `xcodebuild -project mobile/ios/Runner.xcodeproj -scheme Runner -sdk iphoneos -configuration Debug build 2>&1 | tail -20`</verify>
  <done>LocationTrackingService.swift created with full implementation extracted from AppDelegate patterns</done>
</task>

<task type="auto">
  <name>Task 3: Add service files to Xcode project</name>
  <files>mobile/ios/Runner.xcodeproj/project.pbxproj</files>
  <action>
Add the new Swift files to the Xcode project:

Option A (preferred): Use `xcodebuild` won't help here, need to edit project.pbxproj or use ruby script.

Option B (simpler): Since these are Swift files in the Runner directory, they should be auto-detected by Xcode when the directory structure is correct. However, to ensure they're included:

1. Check if Runner.xcodeproj uses folder references or file references
2. If file references (more common), need to add to project.pbxproj

For new Services group:
- Create a group reference in the project file
- Add both .swift files as PBXFileReference
- Add to PBXSourcesBuildPhase

Use the existing patterns in project.pbxproj for how other Swift files (KeychainHelper.swift, etc.) are added.

**Important:** Xcode project file edits are complex. If direct edit fails, create a simple Ruby script:

```ruby
#!/usr/bin/env ruby
require 'xcodeproj'
project = Xcodeproj::Project.open('mobile/ios/Runner.xcodeproj')
runner_group = project.main_group.find_subpath('Runner', false)
services_group = runner_group.new_group('Services', 'Runner/Services')
services_group.new_file('LocationTrackingServiceProtocol.swift')
services_group.new_file('LocationTrackingService.swift')
project.save
```

Run: `cd mobile/ios && ruby add_services.rb && rm add_services.rb`

Alternative: If xcodeproj gem not available, manually verify file discovery by checking Xcode can see them.
  </action>
  <verify>Build succeeds: `cd /Users/boris/zeroclick/mobile/ios && xcodebuild -project Runner.xcodeproj -scheme Runner -sdk iphoneos -configuration Debug build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)" | head -5`</verify>
  <done>Service files added to Xcode project and build succeeds</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Services directory exists at mobile/ios/Runner/Services/
- [ ] LocationTrackingServiceProtocol.swift defines protocol and delegate
- [ ] LocationTrackingService.swift implements protocol with CLLocationManagerDelegate
- [ ] Xcode project builds without errors
- [ ] Files are visible in Xcode project (not just filesystem)
</verification>

<success_criteria>
- All tasks completed
- Xcode build succeeds
- Service files properly structured with protocol/implementation separation
- AppDelegate NOT modified yet (integration in later plan)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ios-native-architecture/02-01-SUMMARY.md`
</output>

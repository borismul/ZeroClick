---
phase: 02-ios-native-architecture
plan: 05
type: execute
depends_on: ["02-04"]
files_modified:
  - mobile/ios/Runner/AppDelegate.swift
domain: ios-native
---

<objective>
Integrate all extracted services into AppDelegate, reducing it from 828 lines to a thin coordinator under 300 lines.

Purpose: Complete the iOS native architecture refactoring by wiring up services and removing duplicated code.
Output: Refactored AppDelegate.swift that delegates to services while maintaining identical behavior.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ios-native-architecture/02-04-SUMMARY.md
@mobile/ios/Runner/AppDelegate.swift

**Services created in 02-01 through 02-04:**
1. LocationTrackingService - CLLocationManager handling
2. MotionActivityHandler - CMMotionActivity detection
3. LiveActivityManager - ActivityKit (Dynamic Island/Lock Screen)
4. WatchConnectivityService - WCSession handling

**What remains in AppDelegate after extraction:**
- Flutter method channel setup and handling
- Service instantiation and wiring
- Drive tracking orchestration (start/stop/ping logic)
- API calls (callStartTripAPI, callPingAPI, callEndTripAPI)
- Notification display (showTripStartedNotification)
- Service delegate implementations

**Target line count:**
- Original: 828 lines
- Target: <300 lines (thin coordinator)
- Services handle the heavy lifting
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor AppDelegate to use services</name>
  <files>mobile/ios/Runner/AppDelegate.swift</files>
  <action>
Refactor AppDelegate to delegate to extracted services:

**1. Replace property declarations (lines 13-34):**

Remove:
```swift
private var locationManager: CLLocationManager!
private var motionManager: CMMotionActivityManager!
private var wcSession: WCSession?
```

Add:
```swift
// MARK: - Services
private var locationService: LocationTrackingServiceProtocol!
private var motionHandler: MotionActivityHandlerProtocol!
private var liveActivityManager: LiveActivityManagerProtocol!
private var watchService: WatchConnectivityServiceProtocol!
```

Keep:
```swift
private var backgroundChannel: FlutterMethodChannel?
private var debugChannel: FlutterMethodChannel?
private var apiBaseUrl: String?
private var userEmail: String?
private var activeCarId: String?
private var isDriving = false
private var isActivelyTracking = false
private var lastLocation: CLLocation?
private var driveStartTime: Date?
private var pingTimer: Timer?
private var totalDistanceMeters: Double = 0
private var lastApiCallTime: Date?
private var lastPingTime: Date?
```

**2. Update didFinishLaunchingWithOptions (around line 167-174):**

Replace:
```swift
setupWatchConnectivity()
if onboardingComplete {
    setupLocationManager()
    setupMotionManager()
    startMonitoring()
}
```

With:
```swift
setupServices()
if onboardingComplete {
    startServices()
}
```

**3. Add new setup methods:**

```swift
// MARK: - Service Setup

private func setupServices() {
    // Create services
    locationService = LocationTrackingService()
    locationService.delegate = self

    motionHandler = MotionActivityHandler()
    motionHandler.delegate = self

    liveActivityManager = createLiveActivityManager()

    watchService = WatchConnectivityService()
    watchService.delegate = self
    watchService.setup()
}

private func startServices() {
    locationService.setupLocationManager()
    motionHandler.setupMotionManager()
    locationService.startMonitoring()
    motionHandler.startActivityUpdates()
    print("[Monitor] Services started")
}

private func stopServices() {
    locationService.stopMonitoring()
    motionHandler.stopActivityUpdates()
    stopDriveTracking()
    print("[Monitor] Services stopped")
}
```

**4. Remove methods that are now in services:**

DELETE these methods (they're in LocationTrackingService):
- `setupLocationManager()` (lines 181-190)
- `setHighAccuracy()` (lines 192-199)
- `setLowAccuracy()` (lines 201-208)
- All `func locationManager(...)` delegate methods (lines 409-452)

DELETE these methods (they're in MotionActivityHandler):
- `setupMotionManager()` (lines 212-214)
- `startMotionUpdates()` (lines 247-258)
- `handleMotionActivity()` (lines 262-286)

DELETE these methods (they're in LiveActivityManager):
- `startLiveActivity()` (lines 696-733)
- `startLiveActivityAsync()` (lines 735-785)
- `updateLiveActivity()` (lines 787-800)
- `endLiveActivity()` (lines 803-827)
- `currentActivityStorage` property (line 694)

DELETE these methods (they're in WatchConnectivityService):
- `setupWatchConnectivity()` (lines 564-573)
- `syncToWatch()` (lines 575-595)
- `syncTokenToWatch()` (lines 597-606)
- `notifyWatchTripStarted()` (lines 608-644)
- All `func session(...)` WCSessionDelegate methods (lines 648-690)

**5. Add service delegate implementations:**

```swift
// MARK: - LocationTrackingServiceDelegate

extension AppDelegate: LocationTrackingServiceDelegate {
    func locationService(_ service: LocationTrackingServiceProtocol, didUpdateLocation location: CLLocation) {
        // During active tracking, accumulate distance and update Live Activity
        if isActivelyTracking {
            if let previous = lastLocation {
                let distance = location.distance(from: previous)
                if distance < 1000 && location.horizontalAccuracy < 50 {
                    totalDistanceMeters += distance
                }
            }

            let distanceKm = totalDistanceMeters / 1000.0
            let durationMinutes = Int(Date().timeIntervalSince(driveStartTime ?? Date()) / 60)
            let avgSpeed = durationMinutes > 0 ? (distanceKm / (Double(durationMinutes) / 60.0)) : 0

            liveActivityManager.updateActivity(state: TripActivityState(
                distanceKm: distanceKm,
                durationMinutes: durationMinutes,
                avgSpeed: avgSpeed,
                startTime: driveStartTime ?? Date(),
                isActive: true
            ))

            sendPing()
        }
        lastLocation = location
    }

    func locationService(_ service: LocationTrackingServiceProtocol, didFailWithError error: Error) {
        print("[Location] Error: \(error.localizedDescription)")
    }

    func locationService(_ service: LocationTrackingServiceProtocol, didChangeAuthorization status: CLAuthorizationStatus) {
        print("[Location] Authorization: \(status.rawValue)")
        if status == .authorizedAlways || status == .authorizedWhenInUse {
            locationService.startMonitoring()
            motionHandler.startActivityUpdates()
        }
    }
}

// MARK: - MotionActivityHandlerDelegate

extension AppDelegate: MotionActivityHandlerDelegate {
    func motionHandler(_ handler: MotionActivityHandlerProtocol, didDetectAutomotive isAutomotive: Bool) {
        if isAutomotive && !isDriving {
            isDriving = true
            let appState = UIApplication.shared.applicationState.rawValue
            debugLog("Motion", "Started DRIVING - triggering startDriveTracking()")
            debugLog("Motion", "App state: \(appState) (0=active, 1=inactive, 2=background)")
            startDriveTracking()
        } else if !isAutomotive && isDriving {
            debugLog("Motion", "Stopped driving")
            isDriving = false
            stopDriveTracking()
        }
    }

    func motionHandler(_ handler: MotionActivityHandlerProtocol, didChangeState state: MotionState) {
        // Could log state changes here if needed
    }
}

// MARK: - WatchConnectivityServiceDelegate

extension AppDelegate: WatchConnectivityServiceDelegate {
    func watchConnectivityService(_ service: WatchConnectivityServiceProtocol, requestsAuthToken completion: @escaping (String?) -> Void) {
        DispatchQueue.main.async {
            self.backgroundChannel?.invokeMethod("getAuthToken", arguments: nil) { result in
                completion(result as? String)
            }
        }
    }

    func watchConnectivityServiceDidActivate(_ service: WatchConnectivityServiceProtocol) {
        if let email = userEmail, let apiUrl = apiBaseUrl, !email.isEmpty {
            watchService.syncConfig(email: email, apiUrl: apiUrl, token: nil)
        }
    }
}
```

**6. Update method channel handlers to use services:**

In setApiConfig handler, replace:
```swift
self?.syncToWatch(email: email, apiUrl: baseUrl, token: nil)
```
With:
```swift
self?.watchService.syncConfig(email: email, apiUrl: baseUrl, token: nil)
```

In startBackgroundMonitoring handler, replace:
```swift
if self?.locationManager == nil {
    self?.setupLocationManager()
    self?.setupMotionManager()
}
self?.startMonitoring()
```
With:
```swift
self?.startServices()
```

In stopBackgroundMonitoring handler, replace:
```swift
self?.stopMonitoring()
```
With:
```swift
self?.stopServices()
```

In isMonitoring handler, replace:
```swift
result(self?.locationManager != nil)
```
With:
```swift
result(self?.locationService?.isMonitoring ?? false)
```

In notifyWatchTripStarted handler, replace:
```swift
self?.notifyWatchTripStarted()
```
With:
```swift
self?.watchService.notifyTripStarted()
```

**7. Update startDriveTracking to use services:**

Replace:
```swift
setHighAccuracy()
// ...
startLiveActivity()
```
With:
```swift
locationService.setHighAccuracy()
// ...
liveActivityManager.startActivity(carName: activeCarId ?? "Auto", startTime: driveStartTime ?? Date())
```

**8. Update stopDriveTracking to use services:**

Replace:
```swift
setLowAccuracy()
endLiveActivity()
```
With:
```swift
locationService.setLowAccuracy()
liveActivityManager.endActivity()
```

**9. Update sendPing to use service:**

Replace:
```swift
guard let location = locationManager.location else {
```
With:
```swift
guard let location = locationService.lastLocation else {
```
  </action>
  <verify>Build succeeds: `cd /Users/boris/zeroclick/mobile/ios && xcodebuild -project Runner.xcodeproj -scheme Runner -sdk iphoneos -configuration Debug build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)" | head -5`</verify>
  <done>AppDelegate refactored to use all services, build succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Verify line count and structure</name>
  <files>mobile/ios/Runner/AppDelegate.swift</files>
  <action>
Verify the refactoring achieved the goals:

1. Count lines: `wc -l mobile/ios/Runner/AppDelegate.swift`
   - Target: <300 lines
   - If over 300, identify remaining cleanup opportunities

2. Check structure - AppDelegate should now have these sections:
   - MARK: - Properties (services + state)
   - MARK: - Debug Logging
   - MARK: - App Lifecycle
   - MARK: - Service Setup
   - MARK: - Drive Tracking (orchestration only)
   - MARK: - Notifications
   - MARK: - API Calls (these stay for now - could be extracted later)
   - MARK: - LocationTrackingServiceDelegate
   - MARK: - MotionActivityHandlerDelegate
   - MARK: - WatchConnectivityServiceDelegate

3. Ensure no CLLocationManager, CMMotionActivityManager, or WCSession direct usage remains in AppDelegate (except through services)

4. Verify all removed CLLocationManagerDelegate, WCSessionDelegate conformance removed from class declaration
  </action>
  <verify>Line count under 300: `wc -l /Users/boris/zeroclick/mobile/ios/Runner/AppDelegate.swift | awk '{print $1}'` should show < 300</verify>
  <done>AppDelegate under 300 lines with clean structure</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Refactored iOS native architecture with services extracted from AppDelegate:
- LocationTrackingService: GPS location management
- MotionActivityHandler: Automotive detection
- LiveActivityManager: Dynamic Island/Lock Screen
- WatchConnectivityService: Apple Watch communication
- AppDelegate: Thin coordinator ~200-300 lines
  </what-built>
  <how-to-verify>
Test on physical iPhone to verify trip detection still works:

1. Build and deploy: `flutter build ios --release` then deploy to device
2. Start driving (or simulate automotive motion)
3. Verify:
   - Trip starts (notification appears)
   - Live Activity shows on Lock Screen / Dynamic Island
   - Apple Watch receives trip notification (if paired)
   - GPS pings are being sent (check API logs)
4. Stop driving
5. Verify:
   - Trip ends properly
   - Live Activity dismisses after 5 minutes

If any feature doesn't work, describe what's broken.
  </how-to-verify>
  <resume-signal>Type "approved" if trip detection works correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] AppDelegate uses services instead of direct manager instances
- [ ] All delegate implementations wire services to AppDelegate
- [ ] Build succeeds without errors
- [ ] AppDelegate is under 300 lines
- [ ] Manual verification confirms trip detection works
</verification>

<success_criteria>
- All tasks completed
- Human verification approved
- AppDelegate reduced from 828 to <300 lines
- Services directory contains 8 files (4 protocols + 4 implementations)
- Trip detection functionality preserved end-to-end
- Phase 2 complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-ios-native-architecture/02-05-SUMMARY.md` with:
- Line count reduction metrics
- Services created
- Any deviations or issues found during integration
</output>

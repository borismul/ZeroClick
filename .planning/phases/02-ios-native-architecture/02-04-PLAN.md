---
phase: 02-ios-native-architecture
plan: 04
type: execute
depends_on: ["02-03"]
files_modified:
  - mobile/ios/Runner/Services/WatchConnectivityService.swift
  - mobile/ios/Runner/Services/WatchConnectivityServiceProtocol.swift
domain: ios-native
---

<objective>
Extract Watch Connectivity functionality from AppDelegate into a dedicated WatchConnectivityService.

Purpose: Isolate WCSession handling, token synchronization, and trip notifications into a testable service.
Output: WatchConnectivityService.swift with protocol for Watch communication.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ios-native-architecture/02-03-SUMMARY.md
@mobile/ios/Runner/AppDelegate.swift

**Extracting from AppDelegate.swift:**
- Lines 564-573: setupWatchConnectivity()
- Lines 575-595: syncToWatch() - applicationContext update
- Lines 597-606: syncTokenToWatch() - transferUserInfo for token
- Lines 608-644: notifyWatchTripStarted() - trip start notification via multiple channels
- Lines 648-690: WCSessionDelegate methods

**Key Watch communication patterns:**
1. applicationContext: Email + API URL (persisted, read on activation)
2. transferUserInfo: Auth token updates, trip notifications (queued delivery)
3. sendMessage: Real-time requests when reachable

**Delegate callback needed:**
- Watch requests auth token → service needs way to get fresh token from Flutter
- Solution: Delegate pattern to request token from AppDelegate

**Established patterns from 02-01/02-02/02-03:**
- Protocol-based dependency injection
- Delegate pattern for callbacks
- MARK comments for organization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WatchConnectivityServiceProtocol</name>
  <files>mobile/ios/Runner/Services/WatchConnectivityServiceProtocol.swift</files>
  <action>
Create protocol file defining the Watch Connectivity interface:

```swift
import WatchConnectivity

protocol WatchConnectivityServiceProtocol: AnyObject {
    var delegate: WatchConnectivityServiceDelegate? { get set }
    var isPaired: Bool { get }
    var isWatchAppInstalled: Bool { get }
    var isReachable: Bool { get }

    /// Initialize WatchConnectivity session
    func setup()

    /// Sync user config to watch via applicationContext
    /// - Parameters:
    ///   - email: User email
    ///   - apiUrl: API base URL
    ///   - token: Optional auth token
    func syncConfig(email: String, apiUrl: String, token: String?)

    /// Send auth token to watch via transferUserInfo (guaranteed delivery)
    /// - Parameter token: Auth token
    func syncToken(_ token: String)

    /// Notify watch that a trip has started
    /// Uses multiple channels for reliability: transferUserInfo, sendMessage, applicationContext
    func notifyTripStarted()

    /// Update trip active state in applicationContext
    /// - Parameter isActive: Whether a trip is currently active
    func updateTripActiveState(_ isActive: Bool)
}

protocol WatchConnectivityServiceDelegate: AnyObject {
    /// Called when watch requests auth token
    /// - Parameter completion: Call with token string or empty if unavailable
    func watchConnectivityService(_ service: WatchConnectivityServiceProtocol, requestsAuthToken completion: @escaping (String?) -> Void)

    /// Called when WCSession activation completes
    func watchConnectivityServiceDidActivate(_ service: WatchConnectivityServiceProtocol)
}
```

The delegate pattern allows service to request auth token from Flutter via AppDelegate's method channel.
  </action>
  <verify>File exists at mobile/ios/Runner/Services/WatchConnectivityServiceProtocol.swift</verify>
  <done>Protocol file created with WatchConnectivityServiceProtocol and Delegate definitions</done>
</task>

<task type="auto">
  <name>Task 2: Create WatchConnectivityService implementation</name>
  <files>mobile/ios/Runner/Services/WatchConnectivityService.swift</files>
  <action>
Extract Watch Connectivity functionality from AppDelegate:

1. Move these methods from AppDelegate:
   - `setupWatchConnectivity()` (lines 564-573)
   - `syncToWatch()` (lines 575-595)
   - `syncTokenToWatch()` (lines 597-606)
   - `notifyWatchTripStarted()` (lines 608-644)
   - All WCSessionDelegate methods (lines 648-690)

2. Service should:
   - Implement `WatchConnectivityServiceProtocol`
   - Conform to `WCSessionDelegate`
   - Own the `WCSession` instance
   - Handle session activation lifecycle
   - Manage applicationContext, transferUserInfo, sendMessage

3. Key behaviors to preserve:
   - Check WCSession.isSupported() before setup
   - Guard isPaired && isWatchAppInstalled before sending
   - Triple-channel notification: transferUserInfo + sendMessage (if reachable) + applicationContext
   - Token request from watch → delegate callback → reply handler

4. Handle watch token request:
```swift
func session(_ session: WCSession, didReceiveMessage message: [String: Any], replyHandler: @escaping ([String: Any]) -> Void) {
    print("[Watch] Received message: \(message)")

    if message["request"] as? String == "authToken" {
        delegate?.watchConnectivityService(self, requestsAuthToken: { token in
            if let token = token, !token.isEmpty {
                print("[Watch] Sending token to watch")
                replyHandler(["authToken": token])
            } else {
                print("[Watch] No token available")
                replyHandler([:])
            }
        })
    } else {
        replyHandler([:])
    }
}
```

Structure:
```swift
import WatchConnectivity

class WatchConnectivityService: NSObject, WatchConnectivityServiceProtocol, WCSessionDelegate {
    // MARK: - Properties
    weak var delegate: WatchConnectivityServiceDelegate?
    private var session: WCSession?

    var isPaired: Bool { session?.isPaired ?? false }
    var isWatchAppInstalled: Bool { session?.isWatchAppInstalled ?? false }
    var isReachable: Bool { session?.isReachable ?? false }

    // MARK: - Setup
    func setup() { ... }

    // MARK: - Sync Methods
    func syncConfig(email: String, apiUrl: String, token: String?) { ... }
    func syncToken(_ token: String) { ... }
    func notifyTripStarted() { ... }
    func updateTripActiveState(_ isActive: Bool) { ... }

    // MARK: - WCSessionDelegate
    // ... all delegate methods
}
```
  </action>
  <verify>Build succeeds: `cd /Users/boris/zeroclick/mobile/ios && xcodebuild -project Runner.xcodeproj -scheme Runner -sdk iphoneos -configuration Debug build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)" | head -5`</verify>
  <done>WatchConnectivityService.swift created with full WCSession handling, build succeeds</done>
</task>

<task type="auto">
  <name>Task 3: Add Watch Connectivity files to Xcode project</name>
  <files>mobile/ios/Runner.xcodeproj/project.pbxproj</files>
  <action>
Add the new Swift files to the Xcode project Services group.

Follow same pattern established in previous plans:
- Add WatchConnectivityServiceProtocol.swift to Services group
- Add WatchConnectivityService.swift to Services group
- Ensure both are in Compile Sources build phase

After adding, verify all 8 service files are in the project:
1. LocationTrackingServiceProtocol.swift
2. LocationTrackingService.swift
3. MotionActivityHandlerProtocol.swift
4. MotionActivityHandler.swift
5. LiveActivityManagerProtocol.swift
6. LiveActivityManager.swift
7. WatchConnectivityServiceProtocol.swift
8. WatchConnectivityService.swift
  </action>
  <verify>Build succeeds with all 8 files: `cd /Users/boris/zeroclick/mobile/ios && xcodebuild -project Runner.xcodeproj -scheme Runner -sdk iphoneos -configuration Debug build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)" | head -5`</verify>
  <done>Watch Connectivity files added to Xcode project, build succeeds with all 8 service files</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] WatchConnectivityServiceProtocol.swift defines protocol and delegate
- [ ] WatchConnectivityService.swift implements protocol with WCSessionDelegate
- [ ] Multi-channel notification preserved (transferUserInfo + sendMessage + applicationContext)
- [ ] Token request delegate pattern allows Flutter integration
- [ ] Xcode project builds without errors
- [ ] All 8 service files compile together
</verification>

<success_criteria>
- All tasks completed
- Xcode build succeeds
- Watch communication functionality properly encapsulated
- Delegate pattern allows token requests from Flutter
- AppDelegate NOT modified yet (integration in next plan)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ios-native-architecture/02-04-SUMMARY.md`
</output>

---
phase: 02-ios-native-architecture
plan: 02
type: execute
depends_on: ["02-01"]
files_modified:
  - mobile/ios/Runner/Services/MotionActivityHandler.swift
  - mobile/ios/Runner/Services/MotionActivityHandlerProtocol.swift
domain: ios-native
---

<objective>
Extract motion activity detection functionality from AppDelegate into a dedicated MotionActivityHandler.

Purpose: Isolate CMMotionActivityManager handling and automotive detection logic into a testable service.
Output: MotionActivityHandler.swift with protocol for mocking motion state changes.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ios-native-architecture/02-01-SUMMARY.md
@mobile/ios/Runner/AppDelegate.swift

**Extracting from AppDelegate.swift:**
- Lines 210-214: setupMotionManager()
- Lines 247-258: startMotionUpdates()
- Lines 262-286: handleMotionActivity() - the automotive detection logic

**Key behavior to preserve:**
- Activity confidence filtering (ignore .low confidence)
- Automotive detection starts tracking
- Stationary detection: backend handles via parked_count (don't immediately stop)
- Walking/running detection stops tracking immediately
- isDriving state tracking

**Established patterns from 02-01:**
- Protocol-based dependency injection
- Delegate pattern for callbacks
- MARK comments for organization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MotionActivityHandlerProtocol</name>
  <files>mobile/ios/Runner/Services/MotionActivityHandlerProtocol.swift</files>
  <action>
Create protocol file defining the motion activity interface:

```swift
import CoreMotion

enum MotionState {
    case unknown
    case stationary
    case walking
    case running
    case automotive
}

protocol MotionActivityHandlerProtocol: AnyObject {
    var delegate: MotionActivityHandlerDelegate? { get set }
    var currentState: MotionState { get }
    var isAutomotive: Bool { get }

    func setupMotionManager()
    func startActivityUpdates()
    func stopActivityUpdates()
}

protocol MotionActivityHandlerDelegate: AnyObject {
    func motionHandler(_ handler: MotionActivityHandlerProtocol, didDetectAutomotive isAutomotive: Bool)
    func motionHandler(_ handler: MotionActivityHandlerProtocol, didChangeState state: MotionState)
}
```

The enum provides cleaner state representation than raw CMMotionActivity. The delegate methods notify AppDelegate of state changes without coupling.
  </action>
  <verify>File exists at mobile/ios/Runner/Services/MotionActivityHandlerProtocol.swift</verify>
  <done>Protocol file created with MotionState enum and MotionActivityHandlerProtocol/Delegate definitions</done>
</task>

<task type="auto">
  <name>Task 2: Create MotionActivityHandler implementation</name>
  <files>mobile/ios/Runner/Services/MotionActivityHandler.swift</files>
  <action>
Extract motion activity functionality from AppDelegate:

1. Move these methods from AppDelegate:
   - `setupMotionManager()` (line 212-214)
   - `startMotionUpdates()` (lines 247-258)
   - Core logic from `handleMotionActivity()` (lines 262-286)

2. Service should:
   - Implement `MotionActivityHandlerProtocol`
   - Own the `CMMotionActivityManager` instance
   - Track `currentState` and `isAutomotive` internally
   - Convert CMMotionActivity to MotionState enum
   - Apply confidence filtering (ignore .low confidence)
   - Notify delegate of automotive detection changes
   - Notify delegate of general state changes

3. Key behavior from original handleMotionActivity():
   - automotive && confidence != .low → set isAutomotive = true, notify delegate
   - stationary && confidence != .low → log but DON'T immediately stop (backend handles)
   - (walking || running) && confidence != .low → set isAutomotive = false, notify delegate

4. Do NOT track wasdriving/isDriving logic in service - that's AppDelegate's orchestration concern. Service just detects and reports.

Structure:
```swift
import CoreMotion

class MotionActivityHandler: MotionActivityHandlerProtocol {
    // MARK: - Properties
    weak var delegate: MotionActivityHandlerDelegate?
    private var motionManager: CMMotionActivityManager!
    private(set) var currentState: MotionState = .unknown
    private(set) var isAutomotive: Bool = false

    // MARK: - Setup
    func setupMotionManager() { ... }

    // MARK: - Activity Updates
    func startActivityUpdates() {
        guard CMMotionActivityManager.isActivityAvailable() else {
            print("[Motion] Activity not available on this device")
            return
        }

        motionManager.startActivityUpdates(to: .main) { [weak self] activity in
            guard let activity = activity else { return }
            self?.processActivity(activity)
        }
        print("[Motion] Activity updates started")
    }

    func stopActivityUpdates() { ... }

    // MARK: - Activity Processing
    private func processActivity(_ activity: CMMotionActivity) {
        // Map to MotionState
        // Apply confidence filter
        // Update currentState and isAutomotive
        // Notify delegate
    }
}
```
  </action>
  <verify>Build succeeds: `cd /Users/boris/zeroclick/mobile/ios && xcodebuild -project Runner.xcodeproj -scheme Runner -sdk iphoneos -configuration Debug build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)" | head -5`</verify>
  <done>MotionActivityHandler.swift created with full implementation, build succeeds</done>
</task>

<task type="auto">
  <name>Task 3: Add motion files to Xcode project</name>
  <files>mobile/ios/Runner.xcodeproj/project.pbxproj</files>
  <action>
Add the new Swift files to the Xcode project Services group.

If 02-01 used xcodeproj gem approach, follow same pattern:
```ruby
#!/usr/bin/env ruby
require 'xcodeproj'
project = Xcodeproj::Project.open('mobile/ios/Runner.xcodeproj')
runner_group = project.main_group.find_subpath('Runner', false)
services_group = runner_group.find_subpath('Services', false)
services_group.new_file('MotionActivityHandlerProtocol.swift')
services_group.new_file('MotionActivityHandler.swift')
project.save
```

If 02-01 used manual approach, follow same pattern for these files.

Ensure files are:
1. Added to project navigator
2. Added to Runner target's Compile Sources build phase
  </action>
  <verify>Build succeeds with all 4 service files: `cd /Users/boris/zeroclick/mobile/ios && xcodebuild -project Runner.xcodeproj -scheme Runner -sdk iphoneos -configuration Debug build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)" | head -5`</verify>
  <done>Motion files added to Xcode project, build succeeds with all service files</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] MotionActivityHandlerProtocol.swift defines MotionState enum, protocol, and delegate
- [ ] MotionActivityHandler.swift implements protocol with CMMotionActivityManager
- [ ] Confidence filtering preserves original behavior (ignore .low)
- [ ] Delegate pattern notifies of automotive detection
- [ ] Xcode project builds without errors
- [ ] All 4 service files (2 location + 2 motion) compile together
</verification>

<success_criteria>
- All tasks completed
- Xcode build succeeds
- Motion detection logic properly encapsulated
- Delegate pattern allows AppDelegate to react to state changes
- AppDelegate NOT modified yet (integration in later plan)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ios-native-architecture/02-02-SUMMARY.md`
</output>

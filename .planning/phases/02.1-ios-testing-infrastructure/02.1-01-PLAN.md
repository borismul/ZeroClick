---
phase: 02.1-ios-testing-infrastructure
plan: 01
type: execute
depends_on: ["02-05"]
files_modified:
  - mobile/ios/RunnerTests/Mocks/MockLocationTrackingService.swift
  - mobile/ios/RunnerTests/Mocks/MockMotionActivityHandler.swift
  - mobile/ios/RunnerTests/Mocks/MockLiveActivityManager.swift
  - mobile/ios/RunnerTests/Mocks/MockWatchConnectivityService.swift
  - mobile/ios/RunnerTests/DriveSimulator.swift
  - mobile/ios/RunnerTests/AppDelegateTests.swift
  - mobile/ios/RunnerTests/TripLifecycleTests.swift
domain: ios-native
---

<objective>
Create comprehensive iOS testing infrastructure with mock services and drive simulation.

Purpose: Enable automated testing of iOS native trip detection without physical device or actual driving.
Output: XCTests that verify all trip lifecycle scenarios run in simulator.
</objective>

<context>
**Services to mock (protocols from Phase 2):**
1. LocationTrackingServiceProtocol - GPS simulation
2. MotionActivityHandlerProtocol - Motion state injection
3. LiveActivityManagerProtocol - Verify Live Activity calls
4. WatchConnectivityServiceProtocol - Verify Watch sync

**Key behaviors to test:**
- Motion automotive → startDriveTracking() called
- Location updates → distance accumulated, pings sent
- Motion stationary → stopDriveTracking() called
- Full trip lifecycle: start → pings → end

**AppDelegate state to verify:**
- isDriving: Bool
- isActivelyTracking: Bool
- totalDistanceMeters: Double
- driveStartTime: Date?
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock service files structure</name>
  <files>mobile/ios/RunnerTests/Mocks/</files>
  <action>
Create the Mocks directory and base files:

```bash
mkdir -p mobile/ios/RunnerTests/Mocks
```

Create MockLocationTrackingService.swift:

```swift
import CoreLocation
@testable import Runner

/// Mock location service for testing
/// Allows injecting GPS coordinates and controlling location updates
class MockLocationTrackingService: LocationTrackingServiceProtocol {
    weak var delegate: LocationTrackingServiceDelegate?

    // MARK: - Protocol Properties

    var isMonitoring: Bool = false
    var lastLocation: CLLocation?

    // MARK: - Test Control Properties

    var setupCalled = false
    var startMonitoringCalled = false
    var stopMonitoringCalled = false
    var highAccuracyEnabled = false
    var lowAccuracyEnabled = false

    // Track all locations sent
    var locationHistory: [CLLocation] = []

    // MARK: - Protocol Methods

    func setupLocationManager() {
        setupCalled = true
    }

    func startMonitoring() {
        startMonitoringCalled = true
        isMonitoring = true
    }

    func stopMonitoring() {
        stopMonitoringCalled = true
        isMonitoring = false
    }

    func setHighAccuracy() {
        highAccuracyEnabled = true
        lowAccuracyEnabled = false
    }

    func setLowAccuracy() {
        lowAccuracyEnabled = true
        highAccuracyEnabled = false
    }

    // MARK: - Test Injection Methods

    /// Inject a location update (simulates GPS)
    func injectLocation(lat: Double, lng: Double, accuracy: Double = 10.0) {
        let location = CLLocation(
            coordinate: CLLocationCoordinate2D(latitude: lat, longitude: lng),
            altitude: 0,
            horizontalAccuracy: accuracy,
            verticalAccuracy: accuracy,
            timestamp: Date()
        )
        injectLocation(location)
    }

    /// Inject a CLLocation directly
    func injectLocation(_ location: CLLocation) {
        lastLocation = location
        locationHistory.append(location)
        delegate?.locationService(self, didUpdateLocation: location)
    }

    /// Inject a sequence of locations with delay
    func injectLocationSequence(_ locations: [CLLocation], intervalSeconds: TimeInterval = 1.0) {
        for (index, location) in locations.enumerated() {
            DispatchQueue.main.asyncAfter(deadline: .now() + intervalSeconds * Double(index)) {
                self.injectLocation(location)
            }
        }
    }

    /// Simulate authorization change
    func injectAuthorizationChange(_ status: CLAuthorizationStatus) {
        delegate?.locationService(self, didChangeAuthorization: status)
    }

    /// Simulate error
    func injectError(_ error: Error) {
        delegate?.locationService(self, didFailWithError: error)
    }

    /// Reset all state for next test
    func reset() {
        isMonitoring = false
        lastLocation = nil
        setupCalled = false
        startMonitoringCalled = false
        stopMonitoringCalled = false
        highAccuracyEnabled = false
        lowAccuracyEnabled = false
        locationHistory.removeAll()
    }
}
```
  </action>
  <verify>File exists: `ls mobile/ios/RunnerTests/Mocks/MockLocationTrackingService.swift`</verify>
  <done>MockLocationTrackingService created with GPS injection methods</done>
</task>

<task type="auto">
  <name>Task 2: Create MockMotionActivityHandler</name>
  <files>mobile/ios/RunnerTests/Mocks/MockMotionActivityHandler.swift</files>
  <action>
Create MockMotionActivityHandler.swift:

```swift
@testable import Runner

/// Mock motion handler for testing
/// Allows injecting motion states (automotive, stationary, walking)
class MockMotionActivityHandler: MotionActivityHandlerProtocol {
    weak var delegate: MotionActivityHandlerDelegate?

    // MARK: - Protocol Properties

    var currentState: MotionState = .unknown
    var isAutomotive: Bool = false

    // MARK: - Test Control Properties

    var setupCalled = false
    var startActivityCalled = false
    var stopActivityCalled = false

    // Track all state changes
    var stateHistory: [MotionState] = []

    // MARK: - Protocol Methods

    func setupMotionManager() {
        setupCalled = true
    }

    func startActivityUpdates() {
        startActivityCalled = true
    }

    func stopActivityUpdates() {
        stopActivityCalled = true
    }

    // MARK: - Test Injection Methods

    /// Simulate starting to drive (automotive motion detected)
    func simulateStartDriving() {
        currentState = .automotive
        isAutomotive = true
        stateHistory.append(.automotive)
        delegate?.motionHandler(self, didDetectAutomotive: true)
        delegate?.motionHandler(self, didChangeState: .automotive)
    }

    /// Simulate stopping (stationary)
    func simulateStopDriving() {
        currentState = .stationary
        isAutomotive = false
        stateHistory.append(.stationary)
        delegate?.motionHandler(self, didDetectAutomotive: false)
        delegate?.motionHandler(self, didChangeState: .stationary)
    }

    /// Simulate walking
    func simulateWalking() {
        currentState = .walking
        isAutomotive = false
        stateHistory.append(.walking)
        delegate?.motionHandler(self, didDetectAutomotive: false)
        delegate?.motionHandler(self, didChangeState: .walking)
    }

    /// Inject any motion state
    func injectState(_ state: MotionState) {
        currentState = state
        isAutomotive = (state == .automotive)
        stateHistory.append(state)
        delegate?.motionHandler(self, didDetectAutomotive: isAutomotive)
        delegate?.motionHandler(self, didChangeState: state)
    }

    /// Reset for next test
    func reset() {
        currentState = .unknown
        isAutomotive = false
        setupCalled = false
        startActivityCalled = false
        stopActivityCalled = false
        stateHistory.removeAll()
    }
}
```
  </action>
  <verify>File exists: `ls mobile/ios/RunnerTests/Mocks/MockMotionActivityHandler.swift`</verify>
  <done>MockMotionActivityHandler created with motion state injection</done>
</task>

<task type="auto">
  <name>Task 3: Create MockLiveActivityManager</name>
  <files>mobile/ios/RunnerTests/Mocks/MockLiveActivityManager.swift</files>
  <action>
Create MockLiveActivityManager.swift:

```swift
@testable import Runner

/// Mock Live Activity manager for testing
/// Verifies Live Activity lifecycle without ActivityKit
class MockLiveActivityManager: LiveActivityManagerProtocol {

    // MARK: - Protocol Properties

    var isActivityRunning: Bool = false

    // MARK: - Test Control Properties

    var startActivityCalled = false
    var updateActivityCalled = false
    var endActivityCalled = false

    var lastCarName: String?
    var lastStartTime: Date?
    var lastState: TripActivityState?
    var lastKeepVisibleDuration: TimeInterval?

    // Track all updates
    var stateUpdates: [TripActivityState] = []

    // MARK: - Protocol Methods

    func startActivity(carName: String, startTime: Date) {
        startActivityCalled = true
        isActivityRunning = true
        lastCarName = carName
        lastStartTime = startTime
    }

    func updateActivity(state: TripActivityState) {
        updateActivityCalled = true
        lastState = state
        stateUpdates.append(state)
    }

    func endActivity(keepVisibleForSeconds: TimeInterval) {
        endActivityCalled = true
        isActivityRunning = false
        lastKeepVisibleDuration = keepVisibleForSeconds
    }

    // MARK: - Test Helpers

    /// Get total distance from all updates
    var totalDistanceKm: Double {
        return lastState?.distanceKm ?? 0
    }

    /// Get update count
    var updateCount: Int {
        return stateUpdates.count
    }

    /// Reset for next test
    func reset() {
        isActivityRunning = false
        startActivityCalled = false
        updateActivityCalled = false
        endActivityCalled = false
        lastCarName = nil
        lastStartTime = nil
        lastState = nil
        lastKeepVisibleDuration = nil
        stateUpdates.removeAll()
    }
}
```
  </action>
  <verify>File exists: `ls mobile/ios/RunnerTests/Mocks/MockLiveActivityManager.swift`</verify>
  <done>MockLiveActivityManager created with activity tracking</done>
</task>

<task type="auto">
  <name>Task 4: Create MockWatchConnectivityService</name>
  <files>mobile/ios/RunnerTests/Mocks/MockWatchConnectivityService.swift</files>
  <action>
Create MockWatchConnectivityService.swift:

```swift
@testable import Runner

/// Mock Watch Connectivity service for testing
/// Verifies Watch communication without WCSession
class MockWatchConnectivityService: WatchConnectivityServiceProtocol {
    weak var delegate: WatchConnectivityServiceDelegate?

    // MARK: - Protocol Properties

    var isPaired: Bool = true
    var isWatchAppInstalled: Bool = true
    var isReachable: Bool = true

    // MARK: - Test Control Properties

    var setupCalled = false
    var syncConfigCalled = false
    var syncTokenCalled = false
    var notifyTripStartedCalled = false
    var updateTripActiveStateCalled = false

    var lastSyncedEmail: String?
    var lastSyncedApiUrl: String?
    var lastSyncedToken: String?
    var lastTripActiveState: Bool?

    var tripStartNotificationCount = 0

    // MARK: - Protocol Methods

    func setup() {
        setupCalled = true
    }

    func syncConfig(email: String, apiUrl: String, token: String?) {
        syncConfigCalled = true
        lastSyncedEmail = email
        lastSyncedApiUrl = apiUrl
        lastSyncedToken = token
    }

    func syncToken(_ token: String) {
        syncTokenCalled = true
        lastSyncedToken = token
    }

    func notifyTripStarted() {
        notifyTripStartedCalled = true
        tripStartNotificationCount += 1
    }

    func updateTripActiveState(_ isActive: Bool) {
        updateTripActiveStateCalled = true
        lastTripActiveState = isActive
    }

    // MARK: - Test Injection Methods

    /// Simulate watch requesting auth token
    func simulateTokenRequest() {
        delegate?.watchConnectivityService(self, requestsAuthToken: { token in
            // Token received from delegate
        })
    }

    /// Simulate activation complete
    func simulateActivation() {
        delegate?.watchConnectivityServiceDidActivate(self)
    }

    /// Reset for next test
    func reset() {
        setupCalled = false
        syncConfigCalled = false
        syncTokenCalled = false
        notifyTripStartedCalled = false
        updateTripActiveStateCalled = false
        lastSyncedEmail = nil
        lastSyncedApiUrl = nil
        lastSyncedToken = nil
        lastTripActiveState = nil
        tripStartNotificationCount = 0
    }
}
```
  </action>
  <verify>File exists: `ls mobile/ios/RunnerTests/Mocks/MockWatchConnectivityService.swift`</verify>
  <done>MockWatchConnectivityService created with Watch sync tracking</done>
</task>

<task type="auto">
  <name>Task 5: Create DriveSimulator for iOS</name>
  <files>mobile/ios/RunnerTests/DriveSimulator.swift</files>
  <action>
Create DriveSimulator.swift - orchestrates complete trip simulation:

```swift
import CoreLocation
@testable import Runner

/// Pre-built drive scenarios (Rotterdam area coordinates)
struct DriveScenarios {
    static let homeLat = 51.9270
    static let homeLng = 4.3620
    static let officeLat = 51.9420
    static let officeLng = 4.4850
    static let skipLat = 51.9350
    static let skipLng = 4.4200

    /// Home to office drive (5 points, ~15km)
    static func homeToOffice() -> [CLLocation] {
        let now = Date()
        return [
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: homeLat, longitude: homeLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10, timestamp: now),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: 51.9300, longitude: 4.3900),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(60)),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: 51.9350, longitude: 4.4200),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(120)),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: 51.9380, longitude: 4.4500),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(180)),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: officeLat, longitude: officeLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(240)),
        ]
    }

    /// Stationary trip (false start)
    static func stationaryTrip() -> [CLLocation] {
        let now = Date()
        return [
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: homeLat, longitude: homeLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10, timestamp: now),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: homeLat, longitude: homeLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(60)),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: homeLat, longitude: homeLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(120)),
        ]
    }

    /// Trip with skip location stop
    static func tripWithSkipLocation() -> [CLLocation] {
        let now = Date()
        return [
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: homeLat, longitude: homeLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10, timestamp: now),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: 51.9300, longitude: 4.3900),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(60)),
            // At skip location
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: skipLat, longitude: skipLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(120)),
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: skipLat, longitude: skipLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(180)),
            // Continue to office
            CLLocation(coordinate: CLLocationCoordinate2D(latitude: officeLat, longitude: officeLng),
                      altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10,
                      timestamp: now.addingTimeInterval(240)),
        ]
    }
}

/// Orchestrates mock services for iOS drive simulation testing
class DriveSimulator {
    let locationService: MockLocationTrackingService
    let motionHandler: MockMotionActivityHandler
    let liveActivityManager: MockLiveActivityManager
    let watchService: MockWatchConnectivityService

    // Current scenario
    private var currentLocations: [CLLocation] = []
    private var currentLocationIndex = 0

    init() {
        locationService = MockLocationTrackingService()
        motionHandler = MockMotionActivityHandler()
        liveActivityManager = MockLiveActivityManager()
        watchService = MockWatchConnectivityService()
    }

    // MARK: - Scenario Setup

    /// Setup home to office drive scenario
    func setupHomeToOfficeTrip() {
        currentLocations = DriveScenarios.homeToOffice()
        currentLocationIndex = 0
    }

    /// Setup stationary trip (should be cancelled)
    func setupStationaryTrip() {
        currentLocations = DriveScenarios.stationaryTrip()
        currentLocationIndex = 0
    }

    /// Setup trip with skip location
    func setupTripWithSkipLocation() {
        currentLocations = DriveScenarios.tripWithSkipLocation()
        currentLocationIndex = 0
    }

    /// Setup custom location sequence
    func setupCustomTrip(_ locations: [CLLocation]) {
        currentLocations = locations
        currentLocationIndex = 0
    }

    // MARK: - Trip Lifecycle

    /// Start the trip (simulates motion detection trigger)
    func startTrip() {
        // Inject first location
        if let firstLocation = currentLocations.first {
            locationService.injectLocation(firstLocation)
        }

        // Trigger automotive detection
        motionHandler.simulateStartDriving()
    }

    /// Trigger next GPS ping
    func triggerPing() {
        currentLocationIndex += 1
        if currentLocationIndex < currentLocations.count {
            locationService.injectLocation(currentLocations[currentLocationIndex])
        }
    }

    /// End the trip (simulates motion stopping)
    func endTrip() {
        motionHandler.simulateStopDriving()
    }

    /// Run complete trip automatically
    func runCompleteTrip() {
        startTrip()

        // Trigger all pings
        while currentLocationIndex < currentLocations.count - 1 {
            triggerPing()
        }

        endTrip()
    }

    // MARK: - Verification Helpers

    /// Check if tracking started
    var didStartTracking: Bool {
        return liveActivityManager.startActivityCalled && locationService.highAccuracyEnabled
    }

    /// Check if tracking stopped
    var didStopTracking: Bool {
        return liveActivityManager.endActivityCalled && locationService.lowAccuracyEnabled
    }

    /// Get number of location updates
    var locationUpdateCount: Int {
        return locationService.locationHistory.count
    }

    /// Get Live Activity update count
    var liveActivityUpdateCount: Int {
        return liveActivityManager.updateCount
    }

    /// Check if Watch was notified
    var didNotifyWatch: Bool {
        return watchService.notifyTripStartedCalled
    }

    /// Reset all mocks for next test
    func reset() {
        locationService.reset()
        motionHandler.reset()
        liveActivityManager.reset()
        watchService.reset()
        currentLocations.removeAll()
        currentLocationIndex = 0
    }
}
```
  </action>
  <verify>File exists: `ls mobile/ios/RunnerTests/DriveSimulator.swift`</verify>
  <done>DriveSimulator created with scenario orchestration</done>
</task>

<task type="auto">
  <name>Task 6: Create TestableAppDelegate</name>
  <files>mobile/ios/RunnerTests/TestableAppDelegate.swift</files>
  <action>
Create TestableAppDelegate.swift - allows injecting mock services:

```swift
import UIKit
@testable import Runner

/// Testable version of AppDelegate that allows service injection
/// Used in XCTests to verify behavior with mock services
class TestableAppDelegate: NSObject {

    // MARK: - Injected Services

    var locationService: LocationTrackingServiceProtocol!
    var motionHandler: MotionActivityHandlerProtocol!
    var liveActivityManager: LiveActivityManagerProtocol!
    var watchService: WatchConnectivityServiceProtocol!

    // MARK: - State (mirrors AppDelegate)

    private(set) var isDriving = false
    private(set) var isActivelyTracking = false
    private(set) var lastLocation: CLLocation?
    private(set) var driveStartTime: Date?
    private(set) var totalDistanceMeters: Double = 0

    // MARK: - Test Observables

    var apiCallsMade: [(type: String, lat: Double, lng: Double)] = []
    var pingCount = 0

    // MARK: - Initialization

    func injectServices(
        location: LocationTrackingServiceProtocol,
        motion: MotionActivityHandlerProtocol,
        liveActivity: LiveActivityManagerProtocol,
        watch: WatchConnectivityServiceProtocol
    ) {
        self.locationService = location
        self.motionHandler = motion
        self.liveActivityManager = liveActivity
        self.watchService = watch

        // Set delegates
        location.delegate = self
        motion.delegate = self
        watch.delegate = self
    }

    func startServices() {
        locationService.setupLocationManager()
        motionHandler.setupMotionManager()
        locationService.startMonitoring()
        motionHandler.startActivityUpdates()
    }

    func stopServices() {
        locationService.stopMonitoring()
        motionHandler.stopActivityUpdates()
        stopDriveTracking()
    }

    // MARK: - Drive Tracking (mirrors AppDelegate logic)

    func startDriveTracking() {
        guard !isActivelyTracking else { return }

        isActivelyTracking = true
        driveStartTime = Date()
        totalDistanceMeters = 0

        locationService.setHighAccuracy()
        liveActivityManager.startActivity(carName: "Test Car", startTime: driveStartTime!)

        // Simulate first ping
        if let location = locationService.lastLocation {
            apiCallsMade.append((type: "start", lat: location.coordinate.latitude, lng: location.coordinate.longitude))
            watchService.notifyTripStarted()
        }
    }

    func stopDriveTracking() {
        guard isActivelyTracking else { return }

        isActivelyTracking = false
        locationService.setLowAccuracy()
        liveActivityManager.endActivity()

        if let location = lastLocation ?? locationService.lastLocation {
            apiCallsMade.append((type: "end", lat: location.coordinate.latitude, lng: location.coordinate.longitude))
        }
    }

    private func sendPing() {
        guard isActivelyTracking else { return }
        guard let location = locationService.lastLocation else { return }

        pingCount += 1
        apiCallsMade.append((type: "ping", lat: location.coordinate.latitude, lng: location.coordinate.longitude))
    }

    // MARK: - Reset

    func reset() {
        isDriving = false
        isActivelyTracking = false
        lastLocation = nil
        driveStartTime = nil
        totalDistanceMeters = 0
        apiCallsMade.removeAll()
        pingCount = 0
    }
}

// MARK: - LocationTrackingServiceDelegate

extension TestableAppDelegate: LocationTrackingServiceDelegate {
    func locationService(_ service: LocationTrackingServiceProtocol, didUpdateLocation location: CLLocation) {
        if isActivelyTracking {
            if let previous = lastLocation {
                let distance = location.distance(from: previous)
                if distance < 1000 && location.horizontalAccuracy < 50 {
                    totalDistanceMeters += distance
                }
            }

            // Update Live Activity
            let distanceKm = totalDistanceMeters / 1000.0
            let durationMinutes = Int(Date().timeIntervalSince(driveStartTime ?? Date()) / 60)
            let avgSpeed = durationMinutes > 0 ? (distanceKm / (Double(durationMinutes) / 60.0)) : 0

            liveActivityManager.updateActivity(state: TripActivityState(
                distanceKm: distanceKm,
                durationMinutes: durationMinutes,
                avgSpeed: avgSpeed,
                startTime: driveStartTime ?? Date(),
                isActive: true
            ))

            sendPing()
        }
        lastLocation = location
    }

    func locationService(_ service: LocationTrackingServiceProtocol, didFailWithError error: Error) {
        // Log error in tests
    }

    func locationService(_ service: LocationTrackingServiceProtocol, didChangeAuthorization status: CLAuthorizationStatus) {
        if status == .authorizedAlways || status == .authorizedWhenInUse {
            locationService.startMonitoring()
            motionHandler.startActivityUpdates()
        }
    }
}

// MARK: - MotionActivityHandlerDelegate

extension TestableAppDelegate: MotionActivityHandlerDelegate {
    func motionHandler(_ handler: MotionActivityHandlerProtocol, didDetectAutomotive isAutomotive: Bool) {
        if isAutomotive && !isDriving {
            isDriving = true
            startDriveTracking()
        } else if !isAutomotive && isDriving {
            isDriving = false
            stopDriveTracking()
        }
    }

    func motionHandler(_ handler: MotionActivityHandlerProtocol, didChangeState state: MotionState) {
        // Could track state changes
    }
}

// MARK: - WatchConnectivityServiceDelegate

extension TestableAppDelegate: WatchConnectivityServiceDelegate {
    func watchConnectivityService(_ service: WatchConnectivityServiceProtocol, requestsAuthToken completion: @escaping (String?) -> Void) {
        completion("test-token")
    }

    func watchConnectivityServiceDidActivate(_ service: WatchConnectivityServiceProtocol) {
        // Sync config on activation
    }
}
```
  </action>
  <verify>File exists: `ls mobile/ios/RunnerTests/TestableAppDelegate.swift`</verify>
  <done>TestableAppDelegate created with service injection</done>
</task>

<task type="auto">
  <name>Task 7: Create XCTest files</name>
  <files>mobile/ios/RunnerTests/TripLifecycleTests.swift</files>
  <action>
Create TripLifecycleTests.swift with comprehensive tests:

```swift
import XCTest
import CoreLocation
@testable import Runner

/// Tests for complete trip lifecycle using mock services
class TripLifecycleTests: XCTestCase {

    var simulator: DriveSimulator!
    var appDelegate: TestableAppDelegate!

    override func setUp() {
        super.setUp()
        simulator = DriveSimulator()
        appDelegate = TestableAppDelegate()
        appDelegate.injectServices(
            location: simulator.locationService,
            motion: simulator.motionHandler,
            liveActivity: simulator.liveActivityManager,
            watch: simulator.watchService
        )
        appDelegate.startServices()
    }

    override func tearDown() {
        simulator.reset()
        appDelegate.reset()
        super.tearDown()
    }

    // MARK: - Motion Detection Tests

    func testAutomotiveDetectionStartsTracking() {
        // Given: Services are running
        XCTAssertFalse(appDelegate.isActivelyTracking)

        // When: Automotive motion detected
        simulator.motionHandler.simulateStartDriving()

        // Then: Tracking starts
        XCTAssertTrue(appDelegate.isDriving)
        XCTAssertTrue(appDelegate.isActivelyTracking)
        XCTAssertTrue(simulator.locationService.highAccuracyEnabled)
        XCTAssertTrue(simulator.liveActivityManager.startActivityCalled)
    }

    func testStationaryStopsTracking() {
        // Given: Currently tracking
        simulator.motionHandler.simulateStartDriving()
        XCTAssertTrue(appDelegate.isActivelyTracking)

        // When: Motion stops
        simulator.motionHandler.simulateStopDriving()

        // Then: Tracking stops
        XCTAssertFalse(appDelegate.isDriving)
        XCTAssertFalse(appDelegate.isActivelyTracking)
        XCTAssertTrue(simulator.locationService.lowAccuracyEnabled)
        XCTAssertTrue(simulator.liveActivityManager.endActivityCalled)
    }

    func testWalkingDoesNotStartTracking() {
        // Given: Not driving
        XCTAssertFalse(appDelegate.isDriving)

        // When: Walking detected
        simulator.motionHandler.simulateWalking()

        // Then: No tracking
        XCTAssertFalse(appDelegate.isDriving)
        XCTAssertFalse(appDelegate.isActivelyTracking)
        XCTAssertFalse(simulator.liveActivityManager.startActivityCalled)
    }

    // MARK: - Location Update Tests

    func testLocationUpdatesAccumulateDistance() {
        // Given: Tracking started
        simulator.setupHomeToOfficeTrip()
        simulator.startTrip()

        // When: Multiple location updates
        simulator.triggerPing()
        simulator.triggerPing()
        simulator.triggerPing()

        // Then: Distance accumulated
        XCTAssertGreaterThan(appDelegate.totalDistanceMeters, 0)
        XCTAssertTrue(simulator.liveActivityManager.updateActivityCalled)
    }

    func testLocationUpdatesSendPings() {
        // Given: Tracking started
        simulator.setupHomeToOfficeTrip()
        simulator.startTrip()

        // When: Location updates
        simulator.triggerPing()
        simulator.triggerPing()

        // Then: Pings sent
        XCTAssertGreaterThan(appDelegate.pingCount, 0)
        let pingCalls = appDelegate.apiCallsMade.filter { $0.type == "ping" }
        XCTAssertGreaterThan(pingCalls.count, 0)
    }

    func testPoorAccuracyLocationsIgnored() {
        // Given: Tracking started
        simulator.motionHandler.simulateStartDriving()
        let initialDistance = appDelegate.totalDistanceMeters

        // When: Poor accuracy location
        simulator.locationService.injectLocation(lat: 51.93, lng: 4.39, accuracy: 100)

        // Then: Distance not changed (accuracy > 50m threshold)
        // Note: First location always sets lastLocation, check on second
        simulator.locationService.injectLocation(lat: 51.94, lng: 4.40, accuracy: 100)

        // Distance should not accumulate for poor accuracy
        // (This depends on implementation - adjust assertion as needed)
    }

    // MARK: - Full Trip Lifecycle Tests

    func testCompleteHomeToOfficeTrip() {
        // Given: Home to office scenario
        simulator.setupHomeToOfficeTrip()

        // When: Complete trip
        simulator.runCompleteTrip()

        // Then: Full lifecycle completed
        XCTAssertTrue(simulator.didStartTracking, "Should have started tracking")
        XCTAssertTrue(simulator.didStopTracking, "Should have stopped tracking")
        XCTAssertTrue(simulator.didNotifyWatch, "Should have notified Watch")
        XCTAssertGreaterThan(simulator.liveActivityUpdateCount, 0, "Should have Live Activity updates")

        // Verify API calls
        let startCalls = appDelegate.apiCallsMade.filter { $0.type == "start" }
        let endCalls = appDelegate.apiCallsMade.filter { $0.type == "end" }
        XCTAssertEqual(startCalls.count, 1, "Should have 1 start call")
        XCTAssertEqual(endCalls.count, 1, "Should have 1 end call")
    }

    func testTripStartCoordinatesCorrect() {
        // Given: Home to office scenario
        simulator.setupHomeToOfficeTrip()

        // When: Trip starts
        simulator.startTrip()

        // Then: Start coordinates are home
        let startCall = appDelegate.apiCallsMade.first { $0.type == "start" }
        XCTAssertNotNil(startCall)
        XCTAssertEqual(startCall?.lat ?? 0, DriveScenarios.homeLat, accuracy: 0.001)
        XCTAssertEqual(startCall?.lng ?? 0, DriveScenarios.homeLng, accuracy: 0.001)
    }

    // MARK: - Watch Connectivity Tests

    func testWatchNotifiedOnTripStart() {
        // Given: Services running
        XCTAssertFalse(simulator.watchService.notifyTripStartedCalled)

        // When: Trip starts
        simulator.setupHomeToOfficeTrip()
        simulator.startTrip()

        // Then: Watch notified
        XCTAssertTrue(simulator.watchService.notifyTripStartedCalled)
        XCTAssertEqual(simulator.watchService.tripStartNotificationCount, 1)
    }

    // MARK: - Live Activity Tests

    func testLiveActivityStartedWithCarName() {
        // Given: Not tracking

        // When: Trip starts
        simulator.motionHandler.simulateStartDriving()

        // Then: Live Activity started
        XCTAssertTrue(simulator.liveActivityManager.startActivityCalled)
        XCTAssertNotNil(simulator.liveActivityManager.lastCarName)
        XCTAssertNotNil(simulator.liveActivityManager.lastStartTime)
    }

    func testLiveActivityUpdatesShowProgress() {
        // Given: Tracking
        simulator.setupHomeToOfficeTrip()
        simulator.startTrip()

        // When: Multiple pings
        simulator.triggerPing()
        simulator.triggerPing()
        simulator.triggerPing()

        // Then: Live Activity updated with increasing distance
        XCTAssertGreaterThan(simulator.liveActivityManager.stateUpdates.count, 0)

        // Verify distance increases
        if simulator.liveActivityManager.stateUpdates.count >= 2 {
            let first = simulator.liveActivityManager.stateUpdates.first!
            let last = simulator.liveActivityManager.stateUpdates.last!
            XCTAssertGreaterThanOrEqual(last.distanceKm, first.distanceKm)
        }
    }

    func testLiveActivityEndsOnTripEnd() {
        // Given: Tracking
        simulator.setupHomeToOfficeTrip()
        simulator.startTrip()

        // When: Trip ends
        simulator.endTrip()

        // Then: Live Activity ended
        XCTAssertTrue(simulator.liveActivityManager.endActivityCalled)
        XCTAssertFalse(simulator.liveActivityManager.isActivityRunning)
    }

    // MARK: - Edge Case Tests

    func testDoubleStartIgnored() {
        // Given: Already tracking
        simulator.motionHandler.simulateStartDriving()
        let initialStartCount = appDelegate.apiCallsMade.filter { $0.type == "start" }.count

        // When: Another start trigger
        simulator.motionHandler.simulateStartDriving()

        // Then: No duplicate start
        let finalStartCount = appDelegate.apiCallsMade.filter { $0.type == "start" }.count
        XCTAssertEqual(initialStartCount, finalStartCount)
    }

    func testStopWithoutStartIgnored() {
        // Given: Not tracking
        XCTAssertFalse(appDelegate.isActivelyTracking)

        // When: Stop without start
        simulator.motionHandler.simulateStopDriving()

        // Then: No end call
        let endCalls = appDelegate.apiCallsMade.filter { $0.type == "end" }
        XCTAssertEqual(endCalls.count, 0)
    }
}
```
  </action>
  <verify>File exists: `ls mobile/ios/RunnerTests/TripLifecycleTests.swift`</verify>
  <done>TripLifecycleTests created with comprehensive test coverage</done>
</task>

<task type="auto">
  <name>Task 8: Add test files to Xcode project</name>
  <files>mobile/ios/Runner.xcodeproj/project.pbxproj</files>
  <action>
Add all new test files to the Xcode project RunnerTests target:

1. MockLocationTrackingService.swift
2. MockMotionActivityHandler.swift
3. MockLiveActivityManager.swift
4. MockWatchConnectivityService.swift
5. DriveSimulator.swift
6. TestableAppDelegate.swift
7. TripLifecycleTests.swift

Ensure all files are in the RunnerTests target's Compile Sources.
  </action>
  <verify>Build and test: `cd /Users/boris/zeroclick/mobile/ios && xcodebuild test -workspace Runner.xcworkspace -scheme Runner -destination 'platform=iOS Simulator,name=iPhone 15' -only-testing:RunnerTests 2>&1 | grep -E "(Test Suite|passed|failed|error:)" | head -20`</verify>
  <done>All test files added to Xcode project, tests run</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 4 mock services created with injection methods
- [ ] DriveSimulator orchestrates complete trip scenarios
- [ ] TestableAppDelegate allows service injection
- [ ] TripLifecycleTests cover all key behaviors
- [ ] Tests run and pass in iOS Simulator
- [ ] No physical device required
</verification>

<success_criteria>
- All tasks completed
- `xcodebuild test` passes in simulator
- Tests cover: motion detection, location updates, Live Activity, Watch sync
- DriveSimulator enables scenario-based testing
- No manual driving verification needed for future phases
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-ios-testing-infrastructure/02.1-01-SUMMARY.md`
</output>

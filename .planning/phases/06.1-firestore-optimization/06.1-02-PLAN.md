---
phase: 06.1-firestore-optimization
plan: 02
type: execute
depends_on: [06.1-01]
files_modified: [watch/MileageWatch/MileageWatch/MileageViewModel.swift, api/services/webhook_service.py]
---

<objective>
Further reduce Firestore costs: eliminate idle polling entirely and consolidate writes during trips.

Purpose: Watch app reads only on-demand (zero idle reads). Webhook pings write cache only once at end.
Output: On-open refresh for Watch, single cache write per ping.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06.1-firestore-optimization/06.1-01-SUMMARY.md

**Problem identified (after 06.1-01):**

**Reads - Watch app still polls:**
- Current: 5-minute timer still runs in background
- Even when not looking at watch: ~41 reads/hour wasted
- User suggestion: Only refresh when app is opened

**Writes - Multiple cache writes per ping:**
- Each `/webhook/ping` calls `set_trip_cache()` 2-5 times depending on code path
- With 60 pings/trip and 3 writes/ping = 180 writes per trip
- Root cause: `set_trip_cache()` called at multiple early-return points in handle_ping()

**Key insight:**
- Cache only needs to persist ONCE at the end of processing
- All intermediate state changes can accumulate in memory, then write once

**Key files:**
@watch/MileageWatch/MileageWatch/MileageViewModel.swift
@api/services/webhook_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Watch app on-open refresh only (eliminate idle polling)</name>
  <files>watch/MileageWatch/MileageWatch/MileageViewModel.swift</files>
  <action>
Replace timer-based polling with on-demand refresh only.

1. Remove the 5-minute background timer entirely. Find and remove:
   - `refreshTimer` property
   - `startAutoRefresh()` timer setup
   - Timer.scheduledTimer calls for background refresh

2. Keep `activeRefreshTimer` for active trips only (30s lightweight status checks).

3. Add scene phase observer to refresh on app open. In the view or ViewModel init:
   ```swift
   // Refresh triggered by ContentView when scenePhase becomes .active
   func refreshOnAppear() async {
       await refreshAll()
   }
   ```

4. In ContentView.swift, add scene phase handling:
   ```swift
   @Environment(\.scenePhase) private var scenePhase

   .onChange(of: scenePhase) { oldPhase, newPhase in
       if newPhase == .active {
           Task {
               await viewModel.refreshOnAppear()
           }
       }
   }
   ```

5. Keep pull-to-refresh for manual refresh on trips list.

6. Keep push notification handling for trip start notifications.

Result:
- Idle watch: ZERO reads (was 41/hour with 5-min polling)
- Active trip: 30s status checks only
- App opened: Full refresh
- Pull-to-refresh: Full refresh
  </action>
  <verify>cd watch/MileageWatch && xcodebuild -scheme MileageWatch -sdk watchsimulator -configuration Debug build CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO 2>&1 | grep -E "(error:|BUILD)" | head -5</verify>
  <done>Watch app uses on-open refresh only, no background timer when idle</done>
</task>

<task type="auto">
  <name>Task 2: Consolidate cache writes - single write per ping</name>
  <files>api/services/webhook_service.py</files>
  <action>
Refactor handle_ping() to write cache only once at the end.

**Current problem:**
```python
def handle_ping(...):
    cache = get_trip_cache(user_id)
    # ... modify cache ...
    set_trip_cache(cache, user_id)  # Write 1
    return {"status": "..."}
    # ... more logic ...
    set_trip_cache(cache, user_id)  # Write 2
    return {"status": "..."}
    # ... etc - 2-5 writes per call
```

**Solution pattern:**
```python
def handle_ping(...):
    cache = get_trip_cache(user_id)
    result = None

    try:
        # ... all processing logic ...
        # ... modify cache in memory only ...
        # ... set result dict ...
        result = {"status": "trip_started", ...}
    finally:
        # Single write at the end
        set_trip_cache(cache, user_id)

    return result
```

**Implementation steps:**

1. At start of handle_ping(), initialize `result = None`

2. Remove ALL intermediate `set_trip_cache()` calls (approximately 12 calls scattered through the function)

3. Before each `return` statement, instead set `result = {...}` and let flow continue to end

4. At the very end of handle_ping(), add single write:
   ```python
   # Single cache write at end of all processing
   set_trip_cache(cache, user_id)
   return result
   ```

5. For early returns that should NOT save (error cases), use `return` directly without setting result, and wrap the final write in a check:
   ```python
   if result is not None:
       set_trip_cache(cache, user_id)
   return result
   ```

**Lines to modify (remove set_trip_cache calls):**
- Line ~110: After Bluetooth+API car assignment
- Line ~122: After API error recovery
- Line ~124: After waiting for API
- Line ~130: After GPS-only mode detected
- Line ~153: After GPS-only fallback trigger
- Line ~161: After waiting for car detection
- Line ~187: After car assignment from API
- Line ~193: After GPS-only mode continued
- Line ~211: After credentials missing fallback
- Line ~220: After car API unavailable
- Line ~298: After paused at skip location
- Line ~362: After continue trip motion tracking

**Result:** 1 write per ping (was 2-5 writes)
  </action>
  <verify>cd api && python -c "from services.webhook_service import webhook_service; print('OK')"</verify>
  <done>handle_ping() writes cache exactly once at the end of processing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Watch app compiles without background timer
- [ ] Watch app refreshes on scenePhase == .active
- [ ] API webhook_service imports without errors
- [ ] handle_ping() has exactly ONE set_trip_cache() call (at end)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Watch idle reads: 0 (was 41/hour)
- Webhook writes per ping: 1 (was 2-5)
- Expected additional reduction: ~90% fewer idle reads, ~60% fewer writes
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-firestore-optimization/06.1-02-SUMMARY.md`:

# Phase 6.1 Plan 02: Firestore Optimization - Reads & Writes

**[Eliminated idle polling, consolidated cache writes to single write per ping]**

## Accomplishments

- Watch app: On-open refresh only (zero idle reads)
- Webhook ping: Single cache write at end of processing

## Files Modified

- `watch/MileageWatch/MileageWatch/MileageViewModel.swift` - Removed background timer
- `watch/MileageWatch/MileageWatch/ContentView.swift` - Added scenePhase handler
- `api/services/webhook_service.py` - Consolidated cache writes

## Estimated Impact

| Metric | After 06.1-01 | After 06.1-02 |
|--------|---------------|---------------|
| Idle watch reads/hour | 41 | 0 |
| Writes per ping | 2-5 | 1 |
| Writes per trip (60 pings) | 120-300 | 60 |

## Next Step

Continue with Phase 6: Error Handling & Logging
</output>

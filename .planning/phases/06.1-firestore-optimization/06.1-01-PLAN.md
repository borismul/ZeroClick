---
phase: 06.1-firestore-optimization
plan: 01
type: execute
depends_on: []
files_modified: [watch/MileageWatch/MileageWatch/MileageViewModel.swift, api/services/car_service.py, api/services/trip_service.py]
---

<objective>
Fix critical Firestore read inefficiencies causing ~590,000 reads/day for a single user.

Purpose: Reduce Firestore costs by 95%+ through proper patterns (real-time listeners, denormalization, cursor pagination).
Output: Watch app uses efficient refresh, car stats denormalized, pagination uses cursors.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Problem identified:**
- Watch app polls every 30 seconds with full data refresh
- Each getCars() call triggers N+1 query (reads ALL trips per car)
- Trip pagination uses offset × 3 (Firestore still reads skipped docs)
- Result: ~590,000 reads/day for single user

**Research findings:**
- Real-time listeners: charged only when data changes, not for connection
- Denormalization: store computed values (total_trips, total_km) in car document
- Cursor pagination: use startAfter() instead of offset (offset still reads internally)
- Firestore offline cache: enable for cache-first reads

**Key files:**
@watch/MileageWatch/MileageWatch/MileageViewModel.swift
@api/services/car_service.py
@api/services/trip_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Watch app polling - increase interval and add smart refresh</name>
  <files>watch/MileageWatch/MileageWatch/MileageViewModel.swift</files>
  <action>
Replace aggressive 30-second polling with smart refresh strategy:

1. Change refresh interval from 30 seconds to 5 minutes (300 seconds) for background refresh:
   ```swift
   // Change line ~39:
   // FROM: Timer.scheduledTimer(withTimeInterval: 30, repeats: true)
   // TO:
   Timer.scheduledTimer(withTimeInterval: 300, repeats: true)
   ```

2. Add active trip detection with faster polling ONLY during active trips:
   ```swift
   private var activeRefreshTimer: Timer?

   func startAutoRefresh() {
       refreshTimer?.invalidate()
       activeRefreshTimer?.invalidate()

       // Background refresh every 5 minutes
       refreshTimer = Timer.scheduledTimer(withTimeInterval: 300, repeats: true) { [weak self] _ in
           Task { @MainActor in
               await self?.refreshAll()
           }
       }
   }

   // Call this when active trip detected
   private func startActiveRefresh() {
       guard activeRefreshTimer == nil else { return }
       activeRefreshTimer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { [weak self] _ in
           Task { @MainActor in
               await self?.refreshActiveTrip()  // Only fetch status, not full data
           }
       }
   }

   private func stopActiveRefresh() {
       activeRefreshTimer?.invalidate()
       activeRefreshTimer = nil
   }

   // Lightweight refresh - only active trip status
   func refreshActiveTrip() async {
       do {
           self.activeTrip = try await APIClient.shared.getStatus()
           if activeTrip?.active != true {
               stopActiveRefresh()
           }
       } catch {
           // Silent fail for status check
       }
   }
   ```

3. In `refreshAll()`, after fetching status, check if trip is active:
   ```swift
   func refreshAll() async {
       // ... existing fetch logic ...

       // Start fast polling only if trip is active
       if self.activeTrip?.active == true {
           startActiveRefresh()
       } else {
           stopActiveRefresh()
       }
   }
   ```

4. Stop timers in deinit or when app backgrounds:
   ```swift
   func stopAutoRefresh() {
       refreshTimer?.invalidate()
       refreshTimer = nil
       activeRefreshTimer?.invalidate()
       activeRefreshTimer = nil
   }
   ```

This reduces reads from 205 every 30s to:
- Idle: 205 every 5 minutes = 41 reads/hour (was 24,600/hour)
- Active trip: 1 read every 30s + 205 every 5 minutes
  </action>
  <verify>cd watch/MileageWatch && xcodebuild -scheme MileageWatch -sdk watchsimulator -configuration Debug build CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO 2>&1 | grep -E "(error:|BUILD)" | head -5</verify>
  <done>Watch refresh interval increased to 5 min for idle, 30s lightweight refresh only during active trip</done>
</task>

<task type="auto">
  <name>Task 2: Denormalize car stats - store in car document</name>
  <files>api/services/car_service.py</files>
  <action>
Remove N+1 query by storing stats directly in car document.

1. Remove the `get_car_stats()` method that queries all trips (lines ~178-194).

2. Modify `get_cars()` to read stats from car document instead of querying trips:
   ```python
   def get_cars(self, user_id: str) -> list[Car]:
       db = get_db()
       cars_ref = db.collection("users").document(user_id).collection("cars")
       cars = []

       for doc in cars_ref.order_by("created_at").stream():
           data = doc.to_dict()
           # Read stats directly from car document (denormalized)
           total_trips = data.get("total_trips", 0)
           total_km = data.get("total_km", 0.0)

           cars.append(Car(
               id=doc.id,
               # ... other fields ...
               total_trips=total_trips,
               total_km=total_km,
           ))

       return cars
   ```

3. Create helper method to update car stats (call after trip finalization):
   ```python
   def update_car_stats(self, user_id: str, car_id: str, km_delta: float, trip_delta: int = 1) -> None:
       """Increment car stats after trip completion. Uses atomic increment."""
       if not car_id:
           return

       db = get_db()
       car_ref = db.collection("users").document(user_id).collection("cars").document(car_id)

       car_ref.update({
           "total_trips": firestore.Increment(trip_delta),
           "total_km": firestore.Increment(km_delta),
       })
   ```

4. Add import at top if not present:
   ```python
   from google.cloud import firestore
   ```

5. In `api/services/trip_service.py`, call `update_car_stats()` after trip finalization.
   Find the `finalize_trip()` method and add after trip is saved:
   ```python
   # After trip saved to Firestore:
   if trip.car_id:
       from services.car_service import car_service
       car_service.update_car_stats(trip.user_id, trip.car_id, trip.distance_km)
   ```

6. For existing data: Add a one-time migration comment noting stats need backfill:
   ```python
   # TODO: Run migration to backfill total_trips/total_km for existing cars
   # SELECT car_id, COUNT(*), SUM(distance_km) FROM trips GROUP BY car_id
   ```

This eliminates the N+1 query entirely. Each getCars() now does 1 read per car (was 1 + all_trips per car).
  </action>
  <verify>cd api && python -c "from services.car_service import car_service; print('OK')"</verify>
  <done>Car stats denormalized, get_cars() reads stats from document, update_car_stats() increments on trip complete</done>
</task>

<task type="auto">
  <name>Task 3: Fix trip pagination - use cursors instead of offset</name>
  <files>api/services/trip_service.py</files>
  <action>
Replace offset-based pagination with cursor-based pagination.

1. Modify `get_trips()` method to use Firestore cursors:

   Current problematic code (loads 3x documents):
   ```python
   if car_id:
       docs = list(query.limit((offset + limit) * 3).stream())
       filtered_docs = [doc for doc in docs if doc.to_dict().get("car_id") == car_id]
   ```

   Replace with proper car_id filtering in query:
   ```python
   def get_trips(
       self,
       user_id: str,
       year: int | None = None,
       month: int | None = None,
       car_id: str | None = None,
       cursor: str | None = None,  # Document ID to start after
       limit: int = 50
   ) -> tuple[list[Trip], str | None]:  # Returns (trips, next_cursor)
       """Get trips with cursor-based pagination."""
       db = get_db()

       query = db.collection("trips").where(
           filter=firestore.FieldFilter("user_id", "==", user_id)
       )

       # Add car_id filter directly to query (requires composite index)
       if car_id:
           query = query.where(
               filter=firestore.FieldFilter("car_id", "==", car_id)
           )

       # Add date filters
       if year:
           start = datetime(year, month or 1, 1)
           end = datetime(year, (month or 12) + 1, 1) if month else datetime(year + 1, 1, 1)
           query = query.where(filter=firestore.FieldFilter("start_time", ">=", start))
           query = query.where(filter=firestore.FieldFilter("start_time", "<", end))

       # Order by start_time descending
       query = query.order_by("start_time", direction=firestore.Query.DESCENDING)

       # Apply cursor if provided
       if cursor:
           cursor_doc = db.collection("trips").document(cursor).get()
           if cursor_doc.exists:
               query = query.start_after(cursor_doc)

       # Fetch limit + 1 to detect if there are more
       docs = list(query.limit(limit + 1).stream())

       # Determine next cursor
       has_more = len(docs) > limit
       if has_more:
           docs = docs[:limit]

       trips = [self._doc_to_trip(doc) for doc in docs]
       next_cursor = docs[-1].id if has_more and docs else None

       return trips, next_cursor
   ```

2. Update the route in `api/routes/trips.py` to use cursor parameter:
   - Change `page: int = 1` to `cursor: str | None = None`
   - Return `{"trips": trips, "next_cursor": next_cursor}`

3. Note: This requires a composite index for (user_id, car_id, start_time).
   Add to firestore.indexes.json or let Firestore auto-create on first query.
   The error message will include a direct link to create the index.

This reduces reads from (offset + limit) * 3 to just (limit + 1).
Example: Page 2 with limit=50 was reading 450 docs, now reads 51.
  </action>
  <verify>cd api && python -c "from services.trip_service import trip_service; print('OK')"</verify>
  <done>Trip pagination uses Firestore cursors, car_id filter in query, reads only limit+1 documents</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Watch app compiles with new refresh logic
- [ ] API services import without errors
- [ ] Car stats are read from document, not computed via N+1 query
- [ ] Trip pagination uses cursor, not offset
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Watch idle refresh: 5 minutes (was 30 seconds)
- Watch active trip: 30s lightweight status check only
- Car stats: 1 read per car (was 1 + all_trips per car)
- Trip pagination: limit+1 reads (was offset×3 reads)
- Expected reduction: ~95% fewer Firestore reads
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-firestore-optimization/06.1-01-SUMMARY.md`:

# Phase 6.1 Plan 01: Firestore Optimization Summary

**[Reduced Firestore reads by ~95% through proper polling, denormalization, and cursor pagination]**

## Accomplishments

- Watch app: 5-min idle refresh, 30s status-only during active trips
- Car stats: Denormalized into car document, eliminates N+1 query
- Trip pagination: Cursor-based, reads only needed documents

## Files Modified

- `watch/MileageWatch/MileageWatch/MileageViewModel.swift` - Smart refresh intervals
- `api/services/car_service.py` - Denormalized stats, removed N+1
- `api/services/trip_service.py` - Cursor pagination

## Estimated Impact

| Before | After |
|--------|-------|
| 590,000 reads/day | ~5,000 reads/day |
| $X/month | ~$0.05X/month |

## Next Step

Continue with Phase 6: Error Handling & Logging
</output>

---
phase: 04-flutter-provider-split
plan: 01
type: execute
depends_on: []
files_modified: [mobile/lib/providers/settings_provider.dart, mobile/lib/providers/app_provider.dart]
---

<objective>
Extract SettingsProvider from AppProvider - the foundation provider that others depend on.

Purpose: Settings is the simplest extraction and establishes the pattern for subsequent providers. Other providers (Trip, Car, Connectivity) need settings for API URLs and configuration.
Output: SettingsProvider managing AppSettings, persistence, and API configuration.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@mobile/lib/providers/app_provider.dart
@mobile/lib/models/settings.dart

**Established patterns:**
- Dart: snake_case files, camelCase methods, leading underscore for private
- Provider: ChangeNotifier pattern with notifyListeners()
- Logging: AppLogger class (`static const _log = AppLogger('ProviderName')`)
- Error handling: Return null/false on failure, log errors with context

**From PROJECT.md:**
- Provider pattern retained, just needs splitting
- All files should be under 500 lines (prefer under 300)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SettingsProvider with settings management</name>
  <files>mobile/lib/providers/settings_provider.dart</files>
  <action>
Create new SettingsProvider extending ChangeNotifier with:

**State from AppProvider to move:**
- `AppSettings _settings`
- `static const String _settingsKey = 'app_settings'`

**Methods from AppProvider to move:**
- `_loadSettings()` -> make public `loadSettings()`
- `saveSettings(AppSettings newSettings)`
- Getters: `settings`, `isConfigured`

**New additions:**
- `static const _log = AppLogger('SettingsProvider')`
- Constructor that calls `Future.microtask(loadSettings)`
- `apiUrl` getter for convenience
- `userEmail` getter for convenience

**Do NOT move:**
- API service management (stays in AppProvider until TripProvider extracts it)
- Auth token handling (stays with API service)

Keep it simple - this is just settings persistence and access.
  </action>
  <verify>File compiles: `cd mobile && flutter analyze lib/providers/settings_provider.dart`</verify>
  <done>SettingsProvider exists with settings state, load/save methods, and proper logging</done>
</task>

<task type="auto">
  <name>Task 2: Integrate SettingsProvider into AppProvider</name>
  <files>mobile/lib/providers/app_provider.dart</files>
  <action>
Modify AppProvider to use SettingsProvider instead of managing settings directly:

1. **Add SettingsProvider dependency:**
   - Add `final SettingsProvider _settingsProvider;` field
   - Update constructor to accept SettingsProvider: `AppProvider(this._settingsProvider)`
   - Remove `_settings` field, `_settingsKey` constant
   - Remove `_loadSettings()` and `saveSettings()` methods

2. **Update all settings references:**
   - `_settings` -> `_settingsProvider.settings`
   - `isConfigured` -> delegate to `_settingsProvider.isConfigured`
   - `saveSettings(...)` calls -> `_settingsProvider.saveSettings(...)`

3. **Update _init():**
   - Remove `await _loadSettings()` call (SettingsProvider handles its own init)
   - Settings should already be loaded when AppProvider is created

4. **Keep API service creation in AppProvider for now:**
   - Still create `_api` with `_settingsProvider.settings.apiUrl` and `_settingsProvider.settings.userEmail`
   - Still call `_api.updateConfig()` when needed

This is a behavioral refactor - external behavior unchanged, internal structure improved.
  </action>
  <verify>
1. `cd mobile && flutter analyze lib/providers/` - no errors
2. Check that AppProvider compiles and settings access works
  </verify>
  <done>AppProvider delegates to SettingsProvider for all settings operations. Settings state removed from AppProvider.</done>
</task>

<task type="auto">
  <name>Task 3: Update main.dart and MultiProvider setup</name>
  <files>mobile/lib/main.dart</files>
  <action>
Update the app's provider setup to include SettingsProvider:

1. **Find existing MultiProvider setup** in main.dart

2. **Add SettingsProvider as first provider:**
   ```dart
   ChangeNotifierProvider(create: (_) => SettingsProvider()),
   ```

3. **Update AppProvider creation to receive SettingsProvider:**
   ```dart
   ChangeNotifierProxyProvider<SettingsProvider, AppProvider>(
     create: (context) => AppProvider(context.read<SettingsProvider>()),
     update: (context, settings, previous) =>
       previous ?? AppProvider(settings),
   ),
   ```

   OR if simpler pattern works:
   ```dart
   ChangeNotifierProvider(
     create: (context) => AppProvider(context.read<SettingsProvider>()),
   ),
   ```

4. **Verify import added:**
   ```dart
   import 'providers/settings_provider.dart';
   ```

The key is SettingsProvider must be created BEFORE AppProvider since AppProvider depends on it.
  </action>
  <verify>
1. `cd mobile && flutter analyze lib/main.dart` - no errors
2. `cd mobile && flutter build ios --debug` - builds successfully
  </verify>
  <done>App initializes with SettingsProvider -> AppProvider dependency chain working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd mobile && flutter analyze` passes with no errors
- [ ] `cd mobile && flutter build ios --debug` succeeds
- [ ] SettingsProvider is under 150 lines
- [ ] AppProvider settings code removed (search for `_settingsKey` should find nothing in app_provider.dart)
</verification>

<success_criteria>
- SettingsProvider exists and manages all settings state
- AppProvider delegates to SettingsProvider (no direct settings management)
- App builds and runs (manual test: settings persist across app restart)
- Code follows established Dart conventions
</success_criteria>

<output>
After completion, create `.planning/phases/04-flutter-provider-split/04-01-SUMMARY.md`
</output>

---
phase: 06-error-handling-logging
plan: 04
type: execute
depends_on: [06-02]
files_modified: [mobile/lib/core/error/error_handler.dart, mobile/lib/core/error/error_dialog.dart, mobile/lib/providers/error_provider.dart]
---

<objective>
Standardize user-facing error handling with a global error handler and consistent UI patterns.

Purpose: Replace ad-hoc SnackBar/AlertDialog usage with consistent, user-friendly error feedback.
Output: Global error handler, standardized error dialog, recovery actions where possible.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Current state:**
- 22 files with try/catch blocks
- 8 files show SnackBar/AlertDialog (mixed patterns)
- No consistent error presentation
- No recovery actions offered

**Target:**
- Global ErrorHandler that categorizes and presents errors
- Consistent ErrorDialog widget
- Recovery actions (retry, dismiss, report)
- Integration with Crashlytics for non-fatal logging

**Key files:**
@mobile/lib/core/api/api_exception.dart (existing exception types)
@mobile/lib/core/logging/app_logger.dart (existing logger)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorHandler class</name>
  <files>mobile/lib/core/error/error_handler.dart</files>
  <action>
Create mobile/lib/core/error/error_handler.dart:

```dart
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import '../api/api_exception.dart';
import '../logging/app_logger.dart';

enum ErrorSeverity { info, warning, error, fatal }

class ErrorInfo {
  final String title;
  final String message;
  final ErrorSeverity severity;
  final bool canRetry;
  final VoidCallback? onRetry;

  ErrorInfo({
    required this.title,
    required this.message,
    this.severity = ErrorSeverity.error,
    this.canRetry = false,
    this.onRetry,
  });
}

class ErrorHandler {
  static ErrorInfo categorize(dynamic error, {VoidCallback? onRetry}) {
    // Network errors - can retry
    if (error is NetworkException) {
      return ErrorInfo(
        title: 'Geen verbinding',
        message: 'Controleer je internetverbinding en probeer opnieuw.',
        severity: ErrorSeverity.warning,
        canRetry: true,
        onRetry: onRetry,
      );
    }

    // Auth errors - need re-login
    if (error is UnauthorizedException) {
      return ErrorInfo(
        title: 'Sessie verlopen',
        message: 'Log opnieuw in om door te gaan.',
        severity: ErrorSeverity.warning,
        canRetry: false,
      );
    }

    // Server errors - can retry
    if (error is ServerException) {
      return ErrorInfo(
        title: 'Serverfout',
        message: 'Er is iets misgegaan. Probeer het later opnieuw.',
        severity: ErrorSeverity.error,
        canRetry: true,
        onRetry: onRetry,
      );
    }

    // Validation errors - user needs to fix input
    if (error is ValidationException) {
      return ErrorInfo(
        title: 'Ongeldige invoer',
        message: error.message ?? 'Controleer je invoer.',
        severity: ErrorSeverity.info,
        canRetry: false,
      );
    }

    // Timeout - can retry
    if (error is TimeoutException) {
      return ErrorInfo(
        title: 'Timeout',
        message: 'De server reageert niet. Probeer opnieuw.',
        severity: ErrorSeverity.warning,
        canRetry: true,
        onRetry: onRetry,
      );
    }

    // Unknown error
    return ErrorInfo(
      title: 'Fout',
      message: 'Er is een onverwachte fout opgetreden.',
      severity: ErrorSeverity.error,
      canRetry: true,
      onRetry: onRetry,
    );
  }

  static void logError(dynamic error, StackTrace? stack, {bool fatal = false}) {
    AppLogger.error('Error occurred', error: error, stackTrace: stack);
    FirebaseCrashlytics.instance.recordError(error, stack, fatal: fatal);
  }
}
```
  </action>
  <verify>cd mobile && test -f lib/core/error/error_handler.dart && echo "OK"</verify>
  <done>ErrorHandler created with error categorization and Dutch messages</done>
</task>

<task type="auto">
  <name>Task 2: Create ErrorDialog widget</name>
  <files>mobile/lib/core/error/error_dialog.dart</files>
  <action>
Create mobile/lib/core/error/error_dialog.dart:

```dart
import 'package:flutter/material.dart';
import 'error_handler.dart';

class ErrorDialog extends StatelessWidget {
  final ErrorInfo errorInfo;
  final VoidCallback? onDismiss;

  const ErrorDialog({
    super.key,
    required this.errorInfo,
    this.onDismiss,
  });

  static Future<void> show(
    BuildContext context,
    ErrorInfo errorInfo, {
    VoidCallback? onDismiss,
  }) {
    return showDialog(
      context: context,
      builder: (ctx) => ErrorDialog(
        errorInfo: errorInfo,
        onDismiss: onDismiss ?? () => Navigator.of(ctx).pop(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      icon: Icon(
        _iconForSeverity(errorInfo.severity),
        color: _colorForSeverity(errorInfo.severity),
        size: 48,
      ),
      title: Text(errorInfo.title),
      content: Text(errorInfo.message),
      actions: [
        if (errorInfo.canRetry && errorInfo.onRetry != null)
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              errorInfo.onRetry!();
            },
            child: const Text('Opnieuw proberen'),
          ),
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
            onDismiss?.call();
          },
          child: const Text('OK'),
        ),
      ],
    );
  }

  IconData _iconForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return Icons.info_outline;
      case ErrorSeverity.warning:
        return Icons.warning_amber_outlined;
      case ErrorSeverity.error:
      case ErrorSeverity.fatal:
        return Icons.error_outline;
    }
  }

  Color _colorForSeverity(ErrorSeverity severity) {
    switch (severity) {
      case ErrorSeverity.info:
        return Colors.blue;
      case ErrorSeverity.warning:
        return Colors.orange;
      case ErrorSeverity.error:
      case ErrorSeverity.fatal:
        return Colors.red;
    }
  }
}
```
  </action>
  <verify>cd mobile && test -f lib/core/error/error_dialog.dart && echo "OK"</verify>
  <done>ErrorDialog widget created with retry support</done>
</task>

<task type="auto">
  <name>Task 3: Create ErrorProvider for global error state</name>
  <files>mobile/lib/providers/error_provider.dart</files>
  <action>
Create mobile/lib/providers/error_provider.dart:

```dart
import 'package:flutter/material.dart';
import '../core/error/error_handler.dart';

class ErrorProvider extends ChangeNotifier {
  ErrorInfo? _currentError;
  ErrorInfo? get currentError => _currentError;

  void showError(dynamic error, {VoidCallback? onRetry}) {
    _currentError = ErrorHandler.categorize(error, onRetry: onRetry);
    notifyListeners();
  }

  void clearError() {
    _currentError = null;
    notifyListeners();
  }

  /// Handle an error with logging and optional UI display
  Future<void> handleError(
    dynamic error,
    StackTrace? stack, {
    VoidCallback? onRetry,
    bool showDialog = true,
    bool fatal = false,
  }) async {
    // Log to Crashlytics
    ErrorHandler.logError(error, stack, fatal: fatal);

    // Show in UI if requested
    if (showDialog) {
      showError(error, onRetry: onRetry);
    }
  }
}
```

Register in MultiProvider in main.dart:
```dart
ChangeNotifierProvider(create: (_) => ErrorProvider()),
```
  </action>
  <verify>cd mobile && test -f lib/providers/error_provider.dart && echo "OK"</verify>
  <done>ErrorProvider created for global error state management</done>
</task>

<task type="auto">
  <name>Task 4: Create ErrorListener widget</name>
  <files>mobile/lib/core/error/error_listener.dart</files>
  <action>
Create mobile/lib/core/error/error_listener.dart to auto-show dialogs:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/error_provider.dart';
import 'error_dialog.dart';

class ErrorListener extends StatefulWidget {
  final Widget child;

  const ErrorListener({super.key, required this.child});

  @override
  State<ErrorListener> createState() => _ErrorListenerState();
}

class _ErrorListenerState extends State<ErrorListener> {
  bool _isShowingDialog = false;

  @override
  Widget build(BuildContext context) {
    return Consumer<ErrorProvider>(
      builder: (context, errorProvider, child) {
        // Show dialog when error changes
        if (errorProvider.currentError != null && !_isShowingDialog) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            _showErrorDialog(context, errorProvider);
          });
        }
        return widget.child;
      },
    );
  }

  Future<void> _showErrorDialog(
    BuildContext context,
    ErrorProvider errorProvider,
  ) async {
    if (_isShowingDialog) return;
    _isShowingDialog = true;

    await ErrorDialog.show(
      context,
      errorProvider.currentError!,
      onDismiss: () {
        errorProvider.clearError();
      },
    );

    _isShowingDialog = false;
  }
}
```

Wrap the app's MaterialApp with ErrorListener:
```dart
ErrorListener(
  child: MaterialApp(...)
)
```
  </action>
  <verify>cd mobile && test -f lib/core/error/error_listener.dart && echo "OK"</verify>
  <done>ErrorListener widget created for automatic error dialogs</done>
</task>

<task type="auto">
  <name>Task 5: Create barrel export and verify Flutter build</name>
  <files>mobile/lib/core/error/error.dart</files>
  <action>
1. Create barrel export file mobile/lib/core/error/error.dart:
```dart
export 'error_dialog.dart';
export 'error_handler.dart';
export 'error_listener.dart';
```

2. Verify Flutter analyzes without errors:
```bash
cd mobile && flutter analyze lib/core/error/
```

3. Verify Flutter builds:
```bash
cd mobile && flutter build ios --debug 2>&1 | grep -E "(error:|BUILD)" | head -5
```
  </action>
  <verify>cd mobile && flutter analyze lib/core/error/ 2>&1 | grep -E "(error|No issues)" | head -3</verify>
  <done>Error module created with barrel export, Flutter build verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ErrorHandler.dart exists with categorization
- [ ] ErrorDialog.dart exists with retry support
- [ ] ErrorProvider.dart exists for state management
- [ ] ErrorListener.dart exists for auto-showing dialogs
- [ ] Barrel export created
- [ ] Flutter analyze passes
- [ ] Dutch error messages used
</verification>

<success_criteria>
- Global error handler categorizes all error types
- Consistent ErrorDialog with retry actions
- ErrorProvider for state management
- ErrorListener for automatic dialog display
- All messages in Dutch
- Flutter build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-handling-logging/06-04-SUMMARY.md`
</output>

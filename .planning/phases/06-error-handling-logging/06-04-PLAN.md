---
phase: 06-error-handling-logging
plan: 04
type: execute
depends_on: ["06-01"]
files_modified: [mobile/lib/core/ui/error_display.dart, mobile/lib/providers/trip_provider.dart, mobile/lib/providers/car_provider.dart, mobile/lib/screens/dashboard_screen.dart, mobile/lib/screens/trips_screen.dart, mobile/lib/screens/cars_screen.dart]
---

<objective>
Add user-facing error messages in Flutter and clean up remaining debug print statements.

Purpose: Show meaningful error messages to users instead of silent failures or console-only logs.
Output: Error snackbars/dialogs for API failures, cleaned up debug prints.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Dependency:** Requires 06-01 completion (AppLogger with Crashlytics integration)

**Current state:**
- Providers have `error` state but it's not consistently shown to users
- Some screens show errors, others fail silently
- debugPrint() used in a few places (charging_map_screen.dart, trip_map_screen.dart)
- AppLogger exists for proper logging

**Key files:**
@mobile/lib/providers/trip_provider.dart
@mobile/lib/providers/car_provider.dart
@mobile/lib/core/api/api_exception.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error display service with snackbar helpers</name>
  <files>mobile/lib/core/ui/error_display.dart</files>
  <action>
Create `mobile/lib/core/ui/error_display.dart`:

```dart
import 'package:flutter/material.dart';
import '../api/api_exception.dart';

/// Service for displaying user-facing error messages
class ErrorDisplay {
  /// Show a snackbar with error message
  /// Call from widget context: ErrorDisplay.showError(context, error)
  static void showError(BuildContext context, Object error, {String? fallbackMessage}) {
    final message = _getErrorMessage(error, fallbackMessage);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red.shade700,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 4),
        action: SnackBarAction(
          label: 'OK',
          textColor: Colors.white,
          onPressed: () {
            ScaffoldMessenger.of(context).hideCurrentSnackBar();
          },
        ),
      ),
    );
  }

  /// Show a snackbar with success message
  static void showSuccess(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green.shade700,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 2),
      ),
    );
  }

  /// Show a warning snackbar (for non-critical issues)
  static void showWarning(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.orange.shade700,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  /// Convert error object to user-friendly message
  static String _getErrorMessage(Object error, String? fallback) {
    // Handle typed API exceptions
    if (error is ApiException) {
      return switch (error) {
        NetworkException() => 'Geen internetverbinding. Controleer je netwerk.',
        UnauthorizedException() => 'Sessie verlopen. Log opnieuw in.',
        ValidationException(message: final msg) => msg,
        ServerException() => 'Server niet bereikbaar. Probeer later opnieuw.',
        TimeoutException() => 'Verzoek duurde te lang. Probeer opnieuw.',
        CancelledException() => 'Verzoek geannuleerd.',
        _ => error.message,
      };
    }

    // Handle string errors
    if (error is String) {
      return error;
    }

    // Fallback
    return fallback ?? 'Er is een fout opgetreden. Probeer opnieuw.';
  }

  /// Show error dialog for critical errors requiring acknowledgment
  static Future<void> showErrorDialog(
    BuildContext context, {
    required String title,
    required String message,
    String? details,
  }) {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(message),
            if (details != null) ...[
              const SizedBox(height: 8),
              Text(
                details,
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey.shade600,
                ),
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
}
```

Note: Error messages are in Dutch to match existing UI language.
  </action>
  <verify>cd mobile && dart analyze lib/core/ui/error_display.dart</verify>
  <done>ErrorDisplay service created with showError, showSuccess, showWarning, and showErrorDialog methods</done>
</task>

<task type="auto">
  <name>Task 2: Add user-facing error handling to key screens</name>
  <files>mobile/lib/screens/dashboard_screen.dart, mobile/lib/screens/trips_screen.dart, mobile/lib/screens/cars_screen.dart</files>
  <action>
Add error display to screens where API failures should be shown to users.

**Pattern to apply:**

1. Add import: `import '../core/ui/error_display.dart';`

2. In build() method or relevant state handlers, listen for provider errors:
   ```dart
   // If there's a method that calls API (like refresh, save, delete)
   // Wrap the call and show error on failure:
   try {
     await provider.someAsyncMethod();
   } catch (e) {
     if (mounted) {
       ErrorDisplay.showError(context, e);
     }
   }
   ```

3. For providers that expose error state, check and display when error changes:
   ```dart
   // In initState or a listener:
   final error = provider.error;
   if (error != null) {
     WidgetsBinding.instance.addPostFrameCallback((_) {
       ErrorDisplay.showError(context, error);
       provider.clearError(); // If method exists
     });
   }
   ```

**Specific changes:**

**dashboard_screen.dart:**
- On trip refresh failure, show error snackbar
- On stats load failure, show error snackbar

**trips_screen.dart:**
- On trip list load failure, show error snackbar
- On trip classification change failure, show error snackbar
- On trip delete failure, show error snackbar

**cars_screen.dart:**
- On car list load failure, show error snackbar
- On car delete failure, show error snackbar
- On OAuth failure, show error snackbar (if not already handled)

Only add error handling where it's currently missing. Don't duplicate existing error handling.
Review each screen's current error handling before adding.
  </action>
  <verify>cd mobile && dart analyze lib/screens/dashboard_screen.dart lib/screens/trips_screen.dart lib/screens/cars_screen.dart</verify>
  <done>Key screens show user-facing error snackbars for API failures</done>
</task>

<task type="auto">
  <name>Task 3: Replace debugPrint with AppLogger and clean up</name>
  <files>mobile/lib/screens/charging_map_screen.dart, mobile/lib/screens/trip_map_screen.dart</files>
  <action>
Find and replace remaining debugPrint() calls with AppLogger:

1. Search for debugPrint in the codebase:
   ```bash
   grep -r "debugPrint" mobile/lib/
   ```

2. For each occurrence:
   - Add import if not present: `import '../core/logging/app_logger.dart';`
   - Create logger instance if not present: `final _logger = AppLogger('ScreenName');`
   - Replace `debugPrint('message')` with `_logger.debug('message')`

3. Known locations:
   - `charging_map_screen.dart` - map loading debug
   - `trip_map_screen.dart` - map/polyline debug

4. Review for any print() statements that should also be converted to AppLogger.

Pattern:
- `debugPrint('Loading markers...')` → `_logger.debug('Loading markers...')`
- `print('Error: $e')` → `_logger.error('Error', e)`

This ensures all logs go through AppLogger which now reports to Crashlytics in production.
  </action>
  <verify>cd mobile && grep -r "debugPrint\|^[^/]*print(" lib/screens/ | grep -v "// " | wc -l should be 0</verify>
  <done>All debugPrint/print statements replaced with AppLogger, no raw prints in screens</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd mobile && dart analyze` passes with no errors
- [ ] `cd mobile && flutter build ios --debug --no-codesign` compiles
- [ ] No debugPrint() calls remain in lib/screens/
- [ ] No unguarded print() calls remain in lib/screens/
- [ ] ErrorDisplay class is importable from screens
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- ErrorDisplay service provides consistent error UI
- Key screens show snackbars for API failures
- No debugPrint() statements remain in screens
- All logging goes through AppLogger (which reports to Crashlytics)
- Phase 6 complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-handling-logging/06-04-SUMMARY.md`:

# Phase 6 Plan 04: User-Facing Error Messages Summary

**[One-liner summary of what was accomplished]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.dart` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 6 complete, ready for Phase 7: Compliance Foundation
</output>

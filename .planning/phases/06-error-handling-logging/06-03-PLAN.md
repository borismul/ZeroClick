---
phase: 06-error-handling-logging
plan: 03
type: execute
depends_on: []
files_modified: [api/middleware/request_context.py, api/main.py, api/utils/error_responses.py]
---

<objective>
Add request correlation and structured error handling to the Python API for better debugging and consistent error responses.

Purpose: Enable request tracing across logs and provide consistent, informative error responses to clients.
Output: All API requests have correlation IDs in logs, and errors return structured JSON responses.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Current state:**
- Basic Python logging configured (logging.basicConfig)
- No request IDs or correlation
- HTTPException used for errors but no global handler
- Error messages are ad-hoc strings

**Concerns from CONCERNS.md:**
- Bare exception handling catches all exceptions including SystemExit
- No global exception handler for consistent error formatting
- No request ID middleware for correlation

**Key files:**
@api/main.py
@api/auth/middleware.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add request correlation middleware</name>
  <files>api/middleware/request_context.py, api/main.py</files>
  <action>
1. Create directory `api/middleware/` if it doesn't exist

2. Create `api/middleware/__init__.py` (empty file)

3. Create `api/middleware/request_context.py`:
```python
"""Request context middleware for correlation IDs and enhanced logging."""
import logging
import time
import uuid
from contextvars import ContextVar
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response

# Context variable for request ID - accessible from anywhere
request_id_var: ContextVar[str] = ContextVar("request_id", default="no-request")

logger = logging.getLogger(__name__)


class RequestContextMiddleware(BaseHTTPMiddleware):
    """Middleware that adds request ID to all requests and logs request/response."""

    async def dispatch(self, request: Request, call_next) -> Response:
        # Generate or extract request ID
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4())[:8])
        request_id_var.set(request_id)

        # Add request ID to request state for access in routes
        request.state.request_id = request_id

        start_time = time.time()
        method = request.method
        path = request.url.path

        # Log request start (skip health checks to reduce noise)
        if path not in ["/health", "/", "/favicon.ico"]:
            logger.info(f"[{request_id}] {method} {path} started")

        try:
            response = await call_next(request)
            duration_ms = (time.time() - start_time) * 1000

            # Log request completion
            if path not in ["/health", "/", "/favicon.ico"]:
                logger.info(
                    f"[{request_id}] {method} {path} completed "
                    f"status={response.status_code} duration={duration_ms:.1f}ms"
                )

            # Add request ID to response headers
            response.headers["X-Request-ID"] = request_id
            return response

        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(
                f"[{request_id}] {method} {path} failed "
                f"error={type(e).__name__}: {str(e)} duration={duration_ms:.1f}ms"
            )
            raise


def get_request_id() -> str:
    """Get current request ID from context. Use in service layer for logging."""
    return request_id_var.get()
```

4. In `api/main.py`, add the middleware BEFORE auth middleware:
   - Add import: `from middleware.request_context import RequestContextMiddleware`
   - Add middleware: `app.add_middleware(RequestContextMiddleware)`
   - Place it BEFORE the existing AuthMiddleware so request ID is available during auth

Order matters: RequestContextMiddleware should be added AFTER CORS middleware but BEFORE AuthMiddleware.
  </action>
  <verify>cd api && python -c "from middleware.request_context import RequestContextMiddleware; print('OK')"</verify>
  <done>RequestContextMiddleware created, all requests have correlation IDs, request/response logging added</done>
</task>

<task type="auto">
  <name>Task 2: Create global exception handler with structured responses</name>
  <files>api/utils/error_responses.py, api/main.py</files>
  <action>
1. Create `api/utils/error_responses.py`:
```python
"""Structured error response utilities."""
from typing import Any, Optional
from pydantic import BaseModel


class ErrorResponse(BaseModel):
    """Standard error response format."""
    error: str
    message: str
    request_id: Optional[str] = None
    details: Optional[dict[str, Any]] = None


class ErrorDetail(BaseModel):
    """Detailed error information for validation errors."""
    field: str
    message: str
    type: str


def create_error_response(
    error_type: str,
    message: str,
    request_id: Optional[str] = None,
    details: Optional[dict[str, Any]] = None
) -> dict:
    """Create a standardized error response dictionary."""
    response = {
        "error": error_type,
        "message": message,
    }
    if request_id:
        response["request_id"] = request_id
    if details:
        response["details"] = details
    return response
```

2. In `api/main.py`, add global exception handlers AFTER app creation but BEFORE routes:

```python
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from middleware.request_context import get_request_id
from utils.error_responses import create_error_response

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Handle HTTPException with structured response."""
    request_id = getattr(request.state, "request_id", None) or get_request_id()
    return JSONResponse(
        status_code=exc.status_code,
        content=create_error_response(
            error_type="http_error",
            message=exc.detail,
            request_id=request_id,
        ),
    )


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle validation errors with detailed field information."""
    request_id = getattr(request.state, "request_id", None) or get_request_id()
    errors = []
    for error in exc.errors():
        errors.append({
            "field": ".".join(str(loc) for loc in error["loc"]),
            "message": error["msg"],
            "type": error["type"],
        })
    return JSONResponse(
        status_code=422,
        content=create_error_response(
            error_type="validation_error",
            message="Request validation failed",
            request_id=request_id,
            details={"errors": errors},
        ),
    )


@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """Handle unexpected exceptions with logging."""
    request_id = getattr(request.state, "request_id", None) or get_request_id()
    logger.exception(f"[{request_id}] Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content=create_error_response(
            error_type="internal_error",
            message="An unexpected error occurred",
            request_id=request_id,
        ),
    )
```

Important: The general exception handler uses `logger.exception()` which includes stack trace.
Do NOT catch BaseException - only Exception (allows KeyboardInterrupt, SystemExit to propagate).
  </action>
  <verify>cd api && python -c "from utils.error_responses import create_error_response; print(create_error_response('test', 'msg', 'req-123'))"</verify>
  <done>Global exception handlers added, all errors return structured JSON with request_id</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd api && python -c "from middleware.request_context import RequestContextMiddleware"` succeeds
- [ ] `cd api && python -c "from utils.error_responses import create_error_response"` succeeds
- [ ] API starts without errors: `cd api && timeout 5 uvicorn main:app --host 0.0.0.0 --port 8080 || true` (should show "Uvicorn running")
- [ ] Request ID appears in response headers (test with curl)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- All API requests have X-Request-ID in response headers
- Request/response logging includes request ID
- HTTP errors return structured JSON with error, message, request_id
- Validation errors include detailed field information
- Unhandled exceptions are logged with stack trace and return generic error
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-handling-logging/06-03-SUMMARY.md`:

# Phase 6 Plan 03: API Structured Logging Summary

**[One-liner summary of what was accomplished]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.py` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 06-04-PLAN.md (User-facing error messages)
</output>

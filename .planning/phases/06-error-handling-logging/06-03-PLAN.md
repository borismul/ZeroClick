---
phase: 06-error-handling-logging
plan: 03
type: execute
depends_on: []
files_modified: [api/main.py, api/middleware/logging.py, api/middleware/request_id.py]
---

<objective>
Add structured JSON logging and request ID tracing to the Python API.

Purpose: Enable production log analysis with request correlation across all services.
Output: JSON-formatted logs with request_id, timestamp, and structured context.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Current state:**
- Python logging module used (537 log calls)
- Plain text format, no structure
- No request IDs for tracing
- Logs not correlated across services

**Target:**
- JSON log format for log aggregation tools
- Request ID header propagation
- Structured context (user_id, trip_id, car_id)
- Error responses include request_id

**Key files:**
@api/main.py
@api/services/webhook_service.py
@api/routes/trips.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add request ID middleware</name>
  <files>api/middleware/request_id.py, api/main.py</files>
  <action>
Create api/middleware/request_id.py:

```python
import uuid
from contextvars import ContextVar
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request

# Context variable for request ID (thread-safe)
request_id_ctx: ContextVar[str] = ContextVar("request_id", default="")

def get_request_id() -> str:
    """Get current request ID from context."""
    return request_id_ctx.get()

class RequestIdMiddleware(BaseHTTPMiddleware):
    """Add request ID to every request for tracing."""

    async def dispatch(self, request: Request, call_next):
        # Use existing header or generate new ID
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4())[:8])
        request_id_ctx.set(request_id)

        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id
        return response
```

In api/main.py, add the middleware:
```python
from middleware.request_id import RequestIdMiddleware

app = FastAPI(...)
app.add_middleware(RequestIdMiddleware)
```
  </action>
  <verify>cd api && python -c "from middleware.request_id import get_request_id; print('OK')"</verify>
  <done>Request ID middleware created and added to FastAPI app</done>
</task>

<task type="auto">
  <name>Task 2: Configure structured JSON logging</name>
  <files>api/main.py, api/middleware/logging.py</files>
  <action>
Create api/middleware/logging.py with JSON formatter:

```python
import json
import logging
import sys
from datetime import datetime
from middleware.request_id import get_request_id

class JsonFormatter(logging.Formatter):
    """Format logs as JSON for structured logging."""

    def format(self, record: logging.LogRecord) -> str:
        log_data = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "request_id": get_request_id() or "-",
        }

        # Add exception info if present
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)

        # Add extra fields if present
        if hasattr(record, "user_id"):
            log_data["user_id"] = record.user_id
        if hasattr(record, "trip_id"):
            log_data["trip_id"] = record.trip_id
        if hasattr(record, "car_id"):
            log_data["car_id"] = record.car_id

        return json.dumps(log_data)


def configure_logging(json_format: bool = True):
    """Configure application logging."""
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)

    # Remove existing handlers
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # Add new handler with appropriate formatter
    handler = logging.StreamHandler(sys.stdout)
    if json_format:
        handler.setFormatter(JsonFormatter())
    else:
        handler.setFormatter(logging.Formatter(
            "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        ))
    root_logger.addHandler(handler)

    # Reduce noise from libraries
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)
```

In api/main.py, call configure_logging at startup:
```python
from middleware.logging import configure_logging
import os

# Configure logging (JSON in production, plain text in dev)
configure_logging(json_format=os.getenv("ENV", "dev") == "prod")
```
  </action>
  <verify>cd api && python -c "from middleware.logging import configure_logging; configure_logging(True); import logging; logging.getLogger().info('test'); print('OK')"</verify>
  <done>JSON structured logging configured with request ID correlation</done>
</task>

<task type="auto">
  <name>Task 3: Add request_id to error responses</name>
  <files>api/main.py</files>
  <action>
Add exception handler that includes request_id in error responses:

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from middleware.request_id import get_request_id

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Handle all unhandled exceptions with request_id."""
    import logging
    logger = logging.getLogger(__name__)
    logger.exception(f"Unhandled exception: {exc}")

    return JSONResponse(
        status_code=500,
        content={
            "detail": "Internal server error",
            "request_id": get_request_id(),
        },
    )

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Add request_id to HTTP exceptions."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "detail": exc.detail,
            "request_id": get_request_id(),
        },
    )
```

This ensures all error responses include a request_id for debugging.
  </action>
  <verify>cd api && python -c "from main import app; print('OK')"</verify>
  <done>Error responses include request_id for debugging</done>
</task>

<task type="auto">
  <name>Task 4: Add logging context to webhook service</name>
  <files>api/services/webhook_service.py</files>
  <action>
Update webhook_service.py to include structured context in logs:

```python
import logging

logger = logging.getLogger(__name__)

# In handle_ping or similar methods:
def handle_ping(self, user_id: str, trip_id: str, data: dict):
    # Create a LogRecord adapter with extra context
    extra = {"user_id": user_id, "trip_id": trip_id}

    logger.info("Processing ping", extra=extra)
    # ... existing logic ...
    logger.info("Ping processed successfully", extra=extra)
```

Or use a helper function:
```python
def log_with_context(logger, level, message, user_id=None, trip_id=None, car_id=None, **kwargs):
    """Log with structured context."""
    extra = {}
    if user_id:
        extra["user_id"] = user_id
    if trip_id:
        extra["trip_id"] = trip_id
    if car_id:
        extra["car_id"] = car_id
    extra.update(kwargs)
    logger.log(level, message, extra=extra)
```
  </action>
  <verify>cd api && grep -c "extra=" services/webhook_service.py | xargs -I {} test {} -gt 0 && echo "OK - context added" || echo "No extra context yet"</verify>
  <done>Webhook service logs include user_id, trip_id context</done>
</task>

<task type="auto">
  <name>Task 5: Verify API starts with structured logging</name>
  <files>api/main.py</files>
  <action>
Test that the API starts correctly with the new logging:

```bash
cd api && timeout 5 uvicorn main:app --host 0.0.0.0 --port 8080 2>&1 | head -20 || true
```

Verify:
1. No import errors
2. Logging is configured
3. JSON format visible in output (if ENV=prod)
  </action>
  <verify>cd api && python -c "from main import app; print('API loads OK')"</verify>
  <done>API starts with structured JSON logging enabled</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Request ID middleware created
- [ ] JSON formatter configured
- [ ] Error responses include request_id
- [ ] Webhook service logs include context
- [ ] API starts without errors
</verification>

<success_criteria>
- Request IDs generated and propagated
- JSON log format enabled for production
- Error responses include request_id
- Webhook logs include user_id, trip_id
- API builds and runs successfully
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-handling-logging/06-03-SUMMARY.md`
</output>

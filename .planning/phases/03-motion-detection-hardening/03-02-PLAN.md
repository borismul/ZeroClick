---
phase: 03-motion-detection-hardening
plan: 02
type: execute
depends_on: ["03-01"]
files_modified: [mobile/ios/RunnerTests/TripLifecycleTests.swift, mobile/ios/Runner/AppDelegate.swift, .planning/phases/03-motion-detection-hardening/STATE_MACHINE.md]
---

<objective>
Add edge case tests and document the motion detection state machine.

Purpose: Ensure all trip detection edge cases are covered by tests and the state machine is documented for future maintenance.
Output: Comprehensive edge case tests and state machine documentation.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-motion-detection-hardening/03-01-SUMMARY.md
@mobile/ios/Runner/Services/MotionActivityHandler.swift
@mobile/ios/Runner/Services/MotionActivityHandlerProtocol.swift
@mobile/ios/Runner/AppDelegate.swift
@mobile/ios/RunnerTests/TripLifecycleTests.swift
@mobile/ios/RunnerTests/MotionDetectionTests.swift

**Tech stack available:** Swift, CMMotionActivity, XCTest
**Established patterns:** Service protocols, delegate pattern, mock testing
**Prior context:** Plan 03-01 added debouncing and confidence thresholds to MotionActivityHandler.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AppDelegate to use confirmed automotive events</name>
  <files>mobile/ios/Runner/AppDelegate.swift</files>
  <action>
Update MotionActivityHandlerDelegate implementation in AppDelegate to respond to debounced confirmations:

1. Add implementation of `motionHandler(_ handler:, didConfirmAutomotive:)`:
   ```swift
   func motionHandler(_ handler: MotionActivityHandlerProtocol, didConfirmAutomotive isAutomotive: Bool) {
       if isAutomotive && !isDriving {
           isDriving = true
           debugLog("Motion", "CONFIRMED driving - triggering startDriveTracking()")
           startDriveTracking()
       } else if !isAutomotive && isDriving {
           debugLog("Motion", "CONFIRMED stopped driving")
           isDriving = false
           stopDriveTracking()
       }
   }
   ```

2. Update existing `didDetectAutomotive` to be logging-only (no trip state changes):
   ```swift
   func motionHandler(_ handler: MotionActivityHandlerProtocol, didDetectAutomotive isAutomotive: Bool) {
       debugLog("Motion", "Detected \(isAutomotive ? "automotive" : "non-automotive") (awaiting confirmation)")
   }
   ```

This ensures trips only start/stop after debounce confirmation, preventing false triggers from rapid oscillation.
  </action>
  <verify>Build succeeds: `cd mobile/ios && xcodebuild -project Runner.xcodeproj -scheme Runner -sdk iphonesimulator -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5`</verify>
  <done>AppDelegate responds to didConfirmAutomotive for trip control, didDetectAutomotive only logs</done>
</task>

<task type="auto">
  <name>Task 2: Add edge case integration tests</name>
  <files>mobile/ios/RunnerTests/TripLifecycleTests.swift</files>
  <action>
Add edge case tests to TripLifecycleTests.swift that use the full TestableAppDelegate + DriveSimulator stack:

**Walk to car scenario:**
- `testWalkToCarDoesNotFalseStart()` - Simulate walking → brief automotive → walking sequence. Trip should NOT start because automotive wasn't confirmed.

**Car in traffic scenario:**
- `testTrafficStopsContinueTrip()` - Simulate automotive → stationary (2s) → automotive. Trip should continue (stationary didn't confirm end).

**Brief stop scenario:**
- `testBriefStopDoesNotEndTrip()` - Simulate trip in progress → stationary for 1s → automotive. Trip continues.

**Actual parking scenario:**
- `testParkingEndsTrip()` - Simulate automotive → stationary for 4+ seconds. Trip ends after debounce confirms.

**Walk after driving:**
- `testWalkingAfterDrivingEndsTrip()` - Simulate automotive (trip started) → walking for 3+ seconds. Trip ends.

**Confidence threshold integration:**
- `testLowConfidenceDoesNotStartTrip()` - Low confidence automotive doesn't start trip.

Use XCTestExpectation with appropriate timeouts for debounce timing (3-5 second tests).
  </action>
  <verify>Tests pass: `cd mobile/ios && xcodebuild test -project Runner.xcodeproj -scheme Runner -sdk iphonesimulator -destination 'platform=iOS Simulator,name=iPhone 16' -only-testing:RunnerTests/TripLifecycleTests 2>&1 | grep -E '(Test Case|passed|failed)'`</verify>
  <done>6+ new edge case tests in TripLifecycleTests.swift, all passing</done>
</task>

<task type="auto">
  <name>Task 3: Document state machine</name>
  <files>.planning/phases/03-motion-detection-hardening/STATE_MACHINE.md</files>
  <action>
Create comprehensive state machine documentation:

```markdown
# Motion Detection State Machine

## Overview

Motion detection uses iOS CMMotionActivity to detect when the user is driving.
The state machine has been hardened with debouncing to prevent false positives.

## States

| State | Description |
|-------|-------------|
| IDLE | Not tracking, monitoring for automotive motion |
| AUTOMOTIVE_PENDING | Automotive detected, awaiting debounce confirmation |
| TRACKING | Actively tracking trip (automotive confirmed) |
| END_PENDING | Non-automotive detected, awaiting debounce confirmation |

## Transitions

```
IDLE ──[automotive detected]──> AUTOMOTIVE_PENDING
AUTOMOTIVE_PENDING ──[debounce timeout (2s)]──> TRACKING
AUTOMOTIVE_PENDING ──[non-automotive before timeout]──> IDLE

TRACKING ──[stationary/walking detected]──> END_PENDING
END_PENDING ──[debounce timeout (3s)]──> IDLE (trip ends)
END_PENDING ──[automotive before timeout]──> TRACKING (trip continues)
```

## Configuration

| Parameter | Default | Description |
|-----------|---------|-------------|
| minimumConfidence | .medium | Minimum CMMotionActivityConfidence to accept |
| automotiveDebounceSeconds | 2.0 | Wait time before confirming trip start |
| nonAutomotiveDebounceSeconds | 3.0 | Wait time before confirming trip end |

## Edge Cases Handled

1. **Walk to car**: Walking → brief automotive → walking = no trip (automotive not confirmed)
2. **Traffic**: Automotive → stationary → automotive within 3s = trip continues
3. **Brief stop**: Stop at light, gas station = trip continues if < 3s
4. **Actual parking**: Stationary > 3s = trip ends
5. **Low confidence**: Low confidence events ignored entirely

## Confidence Levels

CMMotionActivityConfidence maps to:
- `.low` (0) - Unreliable, always ignored
- `.medium` (1) - Default minimum threshold
- `.high` (2) - Most reliable

## Files

- `MotionActivityHandlerProtocol.swift` - Protocol defining the interface
- `MotionActivityHandler.swift` - Implementation with debounce logic
- `AppDelegate.swift` - Responds to confirmed events only
- `MotionDetectionTests.swift` - Unit tests for debounce logic
- `TripLifecycleTests.swift` - Integration tests for edge cases
```
  </action>
  <verify>File exists and contains state diagram: `cat .planning/phases/03-motion-detection-hardening/STATE_MACHINE.md | head -30`</verify>
  <done>STATE_MACHINE.md documents states, transitions, configuration, and edge cases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodebuild build` succeeds
- [ ] All TripLifecycleTests pass
- [ ] AppDelegate uses confirmed events for trip control
- [ ] STATE_MACHINE.md documents the state machine
- [ ] All edge cases have test coverage
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- AppDelegate responds to debounced confirmations only
- 6+ edge case integration tests passing
- State machine fully documented
- Phase 3 complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-motion-detection-hardening/03-02-SUMMARY.md`:

# Phase 03 Plan 02: Edge Cases and Documentation Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 3 complete, ready for Phase 4: Flutter Provider Split
</output>

---
phase: 01-testing-infrastructure-mocks
plan: 02
type: execute
depends_on: ["01-01"]
files_modified:
  - mobile/test/mocks/mock_api_service.dart
  - mobile/test/mocks/mock_bluetooth_service.dart
  - mobile/test/mocks/mock_background_service.dart
  - mobile/test/fixtures/api_responses.dart
  - mobile/test/fixtures/drive_scenarios.dart
domain: flutter
---

<objective>
Create comprehensive mock services for Bluetooth, Background (native), and API, plus test fixtures for all webhook response scenarios.

Purpose: Complete the Flutter mock infrastructure so we can test car detection, native integration, and API responses without real hardware or network calls.

Output: MockApiService, MockBluetoothService, MockBackgroundService, and fixture data for all stress test scenarios from ROADMAP.md.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-testing-infrastructure-mocks/1-RESEARCH.md
@.planning/phases/01-testing-infrastructure-mocks/01-01-SUMMARY.md

**Key files to reference:**
@mobile/lib/services/api_service.dart
@mobile/lib/services/bluetooth_service.dart
@mobile/lib/services/background_service.dart

**From research:**
- BluetoothService uses MethodChannel 'com.zeroclick/bluetooth'
- BackgroundService uses MethodChannel 'com.zeroclick/background'
- Use TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler for channel mocking
- ApiService webhook methods: startTrip, endTrip, sendPing, finalize, cancel, getStatus

**Stress test scenarios from ROADMAP (fixture data needed):**
- API 502/503 mid-trip
- is_parked=True but odometer increases
- API state=unknown
- All car APIs fail for 2+ pings
- Skip location scenarios
- Bluetooth + API conflicts
- Counter threshold tests
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MockApiService with mocktail</name>
  <files>mobile/test/mocks/mock_api_service.dart</files>
  <action>
Create a mock API service using mocktail for stubbing webhook responses:

```dart
import 'package:mocktail/mocktail.dart';
import 'package:mileage_tracker/services/api_service.dart';
import 'package:mileage_tracker/models/trip.dart';
import 'package:mileage_tracker/models/car.dart';

/// Mock API service for testing webhook flows
class MockApiService extends Mock implements ApiService {}

/// Register fallback values for mocktail any() matchers
void registerApiServiceFallbacks() {
  registerFallbackValue(0.0); // for lat/lng
  registerFallbackValue(''); // for strings
  registerFallbackValue(<String, dynamic>{}); // for maps
}
```

This uses mocktail's automatic stubbing - tests will use `when(() => mockApi.sendPing(...)).thenAnswer(...)` pattern.

Keep it minimal - mocktail handles the heavy lifting. The fixtures file (Task 3) will contain the response data.
  </action>
  <verify>cd mobile && flutter analyze test/mocks/mock_api_service.dart shows no errors</verify>
  <done>MockApiService extends Mock implements ApiService, fallback registration helper exists</done>
</task>

<task type="auto">
  <name>Task 2: Create MockBluetoothService and MockBackgroundService</name>
  <files>mobile/test/mocks/mock_bluetooth_service.dart, mobile/test/mocks/mock_background_service.dart</files>
  <action>
Create mock implementations for the native MethodChannel services.

**mock_bluetooth_service.dart:**
```dart
import 'package:mileage_tracker/services/bluetooth_service.dart';

/// Fake Bluetooth service for testing car detection without real Bluetooth
class FakeBluetoothService implements BluetoothService {
  String? _connectedDevice;
  BluetoothCallback? _callback;

  // === Test Setup Methods ===

  /// Simulate connecting to a Bluetooth device
  void simulateConnect(String deviceName) {
    _connectedDevice = deviceName;
    _callback?.call(deviceName);
  }

  /// Simulate disconnecting from Bluetooth
  void simulateDisconnect() {
    _connectedDevice = null;
    _callback?.call(null);
  }

  /// Reset state between tests
  void reset() {
    _connectedDevice = null;
    _callback = null;
  }

  // === BluetoothService Interface ===

  @override
  Future<String?> getConnectedDevice() async => _connectedDevice;

  @override
  Future<bool> checkConnection() async => _connectedDevice != null;

  @override
  void setConnectionCallback(BluetoothCallback callback) {
    _callback = callback;
  }

  @override
  String? get connectedDevice => _connectedDevice;

  @override
  bool get isConnected => _connectedDevice != null;

  @override
  void dispose() {
    _callback = null;
  }
}
```

**mock_background_service.dart:**
```dart
import 'package:mileage_tracker/services/background_service.dart';

/// Fake Background service for testing native iOS integration
class FakeBackgroundService implements BackgroundService {
  bool _isMonitoring = false;
  bool _isActivelyTracking = false;
  String? _apiBaseUrl;
  String? _userEmail;
  String? _authToken;
  String? _activeCarId;

  CarDetectedCallback? _carDetectedCallback;
  LocationUpdateCallback? _locationUpdateCallback;
  TripEndedCallback? _tripEndedCallback;

  // === Test Setup Methods ===

  /// Simulate car being detected (triggers trip start flow)
  void simulateCarDetected(String deviceName, double lat, double lng) {
    _carDetectedCallback?.call(deviceName, lat, lng);
  }

  /// Simulate location update from native
  void simulateLocationUpdate(double lat, double lng) {
    _locationUpdateCallback?.call(lat, lng);
  }

  /// Simulate trip ended from native
  void simulateTripEnded(String status) {
    _tripEndedCallback?.call(status);
  }

  /// Reset state between tests
  void reset() {
    _isMonitoring = false;
    _isActivelyTracking = false;
    _apiBaseUrl = null;
    _userEmail = null;
    _authToken = null;
    _activeCarId = null;
    _carDetectedCallback = null;
    _locationUpdateCallback = null;
    _tripEndedCallback = null;
  }

  // === Getters for test verification ===
  String? get configuredBaseUrl => _apiBaseUrl;
  String? get configuredEmail => _userEmail;
  String? get configuredToken => _authToken;
  String? get configuredCarId => _activeCarId;

  // === BackgroundService Interface ===

  @override
  void setCarDetectedCallback(CarDetectedCallback callback) {
    _carDetectedCallback = callback;
  }

  @override
  void setLocationUpdateCallback(LocationUpdateCallback callback) {
    _locationUpdateCallback = callback;
  }

  @override
  void setTripEndedCallback(TripEndedCallback callback) {
    _tripEndedCallback = callback;
  }

  @override
  Future<bool> startMonitoring() async {
    _isMonitoring = true;
    return true;
  }

  @override
  Future<bool> stopMonitoring() async {
    _isMonitoring = false;
    return true;
  }

  @override
  Future<bool> isMonitoring() async => _isMonitoring;

  @override
  Future<bool> setApiConfig(String baseUrl, String userEmail) async {
    _apiBaseUrl = baseUrl;
    _userEmail = userEmail;
    return true;
  }

  @override
  Future<bool> setAuthToken(String token) async {
    _authToken = token;
    return true;
  }

  @override
  Future<bool> setActiveCarId(String? carId) async {
    _activeCarId = carId;
    return true;
  }

  @override
  Future<bool> clearActiveCarId() async {
    _activeCarId = null;
    return true;
  }

  @override
  Future<bool> notifyWatchTripStarted() async => true;

  @override
  Future<bool> startActiveTracking() async {
    _isActivelyTracking = true;
    return true;
  }

  @override
  Future<bool> stopActiveTracking() async {
    _isActivelyTracking = false;
    return true;
  }

  @override
  Future<bool> isActivelyTracking() async => _isActivelyTracking;

  @override
  Future<bool> startTrip() async => true;

  @override
  Future<bool> endTrip() async => true;
}
```

Note: These are "Fake" implementations (stateful test doubles) rather than "Mock" (mocktail stubs) because we need to control their behavior programmatically during drive simulation.
  </action>
  <verify>cd mobile && flutter analyze test/mocks/mock_bluetooth_service.dart test/mocks/mock_background_service.dart shows no errors</verify>
  <done>FakeBluetoothService and FakeBackgroundService implement their interfaces with simulation helpers</done>
</task>

<task type="auto">
  <name>Task 3: Create API response fixtures and drive scenario fixtures</name>
  <files>mobile/test/fixtures/api_responses.dart, mobile/test/fixtures/drive_scenarios.dart</files>
  <action>
Create fixture data for all stress test scenarios.

**api_responses.dart:**
```dart
import 'package:mileage_tracker/services/location_service.dart';

/// API response fixtures for testing webhook flows
class ApiResponses {
  // === Ping Responses ===

  /// Normal driving response
  static Map<String, dynamic> drivingResponse({
    String carId = 'car-123',
    String carName = 'Audi A4',
    double distanceKm = 5.0,
    int parkedCount = 0,
  }) => {
    'status': 'driving',
    'car_id': carId,
    'car_name': carName,
    'distance_km': distanceKm,
    'parked_count': parkedCount,
    'no_driving_count': 0,
    'api_error_count': 0,
  };

  /// Parked response (car API reports parked)
  static Map<String, dynamic> parkedResponse({
    int parkedCount = 1,
    double distanceKm = 10.0,
  }) => {
    'status': 'parked',
    'parked_count': parkedCount,
    'distance_km': distanceKm,
    'no_driving_count': 0,
    'api_error_count': 0,
  };

  /// No car driving found response
  static Map<String, dynamic> noCarDrivingResponse({
    int noDrivingCount = 1,
  }) => {
    'status': 'no_car_driving',
    'no_driving_count': noDrivingCount,
    'parked_count': 0,
    'api_error_count': 0,
  };

  /// API error response (car API failed)
  static Map<String, dynamic> apiErrorResponse({
    int apiErrorCount = 1,
  }) => {
    'status': 'api_error',
    'api_error_count': apiErrorCount,
    'no_driving_count': 0,
    'parked_count': 0,
  };

  /// GPS-only mode active
  static Map<String, dynamic> gpsOnlyResponse({
    double distanceKm = 5.0,
  }) => {
    'status': 'gps_only',
    'gps_only_mode': true,
    'distance_km': distanceKm,
  };

  /// At skip location (paused)
  static Map<String, dynamic> skipLocationResponse({
    int skipPauseCount = 1,
  }) => {
    'status': 'skip_paused',
    'skip_pause_count': skipPauseCount,
    'at_skip_location': true,
  };

  // === Start/End Responses ===

  static Map<String, dynamic> tripStartedResponse({
    String tripId = 'trip-abc123',
  }) => {
    'status': 'started',
    'trip_id': tripId,
  };

  static Map<String, dynamic> tripFinalizedResponse({
    String tripId = 'trip-abc123',
    double totalKm = 15.5,
  }) => {
    'status': 'finalized',
    'trip_id': tripId,
    'total_km': totalKm,
  };

  static Map<String, dynamic> tripCancelledResponse() => {
    'status': 'cancelled',
  };

  // === Error Responses (for simulating failures) ===

  /// Simulates 502 Bad Gateway
  static Exception serverError502() => Exception('502 Bad Gateway');

  /// Simulates 503 Service Unavailable
  static Exception serverError503() => Exception('503 Service Unavailable');

  /// Simulates network timeout
  static Exception networkTimeout() => Exception('Connection timed out');
}
```

**drive_scenarios.dart:**
```dart
import 'package:mileage_tracker/services/location_service.dart';

/// Pre-built drive scenarios for integration testing
class DriveScenarios {
  /// Home coordinates (configurable)
  static const double homeLat = 51.9270;
  static const double homeLng = 4.3620;

  /// Office coordinates (configurable)
  static const double officeLat = 51.9420;
  static const double officeLng = 4.4850;

  /// Skip location (e.g., gas station)
  static const double skipLat = 51.9350;
  static const double skipLng = 4.4200;

  /// Generate a simple home-to-office drive (5 pings, ~15km)
  static List<LocationResult> homeToOffice() {
    final now = DateTime.now();
    return [
      LocationResult(lat: homeLat, lng: homeLng, timestamp: now),
      LocationResult(lat: 51.9300, lng: 4.3900, timestamp: now.add(const Duration(minutes: 1))),
      LocationResult(lat: 51.9350, lng: 4.4200, timestamp: now.add(const Duration(minutes: 2))),
      LocationResult(lat: 51.9380, lng: 4.4500, timestamp: now.add(const Duration(minutes: 3))),
      LocationResult(lat: officeLat, lng: officeLng, timestamp: now.add(const Duration(minutes: 4))),
    ];
  }

  /// Short trip that should be skipped (<0.1km)
  static List<LocationResult> tooShortTrip() {
    final now = DateTime.now();
    return [
      LocationResult(lat: homeLat, lng: homeLng, timestamp: now),
      LocationResult(lat: homeLat + 0.0001, lng: homeLng + 0.0001, timestamp: now.add(const Duration(minutes: 1))),
    ];
  }

  /// Trip that visits skip location mid-way
  static List<LocationResult> tripWithSkipLocation() {
    final now = DateTime.now();
    return [
      LocationResult(lat: homeLat, lng: homeLng, timestamp: now),
      LocationResult(lat: 51.9300, lng: 4.3900, timestamp: now.add(const Duration(minutes: 1))),
      // At skip location for multiple pings
      LocationResult(lat: skipLat, lng: skipLng, timestamp: now.add(const Duration(minutes: 2))),
      LocationResult(lat: skipLat, lng: skipLng, timestamp: now.add(const Duration(minutes: 3))),
      LocationResult(lat: skipLat, lng: skipLng, timestamp: now.add(const Duration(minutes: 4))),
      // Continue to office
      LocationResult(lat: 51.9380, lng: 4.4500, timestamp: now.add(const Duration(minutes: 5))),
      LocationResult(lat: officeLat, lng: officeLng, timestamp: now.add(const Duration(minutes: 6))),
    ];
  }

  /// Stationary trip (false start - no movement)
  static List<LocationResult> stationaryTrip() {
    final now = DateTime.now();
    return [
      LocationResult(lat: homeLat, lng: homeLng, timestamp: now),
      LocationResult(lat: homeLat, lng: homeLng, timestamp: now.add(const Duration(minutes: 1))),
      LocationResult(lat: homeLat, lng: homeLng, timestamp: now.add(const Duration(minutes: 2))),
    ];
  }

  /// Long trip with traffic (15 pings, same location repeated = traffic jam)
  static List<LocationResult> tripWithTraffic() {
    final now = DateTime.now();
    return [
      LocationResult(lat: homeLat, lng: homeLng, timestamp: now),
      LocationResult(lat: 51.9300, lng: 4.3900, timestamp: now.add(const Duration(minutes: 1))),
      // Traffic jam - 5 pings at same location
      LocationResult(lat: 51.9320, lng: 4.4000, timestamp: now.add(const Duration(minutes: 2))),
      LocationResult(lat: 51.9320, lng: 4.4000, timestamp: now.add(const Duration(minutes: 3))),
      LocationResult(lat: 51.9320, lng: 4.4000, timestamp: now.add(const Duration(minutes: 4))),
      LocationResult(lat: 51.9320, lng: 4.4000, timestamp: now.add(const Duration(minutes: 5))),
      LocationResult(lat: 51.9320, lng: 4.4000, timestamp: now.add(const Duration(minutes: 6))),
      // Traffic clears
      LocationResult(lat: 51.9380, lng: 4.4500, timestamp: now.add(const Duration(minutes: 7))),
      LocationResult(lat: officeLat, lng: officeLng, timestamp: now.add(const Duration(minutes: 8))),
    ];
  }

  /// Generate custom drive with N pings between two points
  static List<LocationResult> customDrive({
    required double startLat,
    required double startLng,
    required double endLat,
    required double endLng,
    required int pingCount,
    Duration pingInterval = const Duration(minutes: 1),
  }) {
    final now = DateTime.now();
    final latStep = (endLat - startLat) / (pingCount - 1);
    final lngStep = (endLng - startLng) / (pingCount - 1);

    return List.generate(pingCount, (i) => LocationResult(
      lat: startLat + (latStep * i),
      lng: startLng + (lngStep * i),
      timestamp: now.add(pingInterval * i),
    ));
  }
}
```

Ensure LocationResult is imported from the services. If LocationResult is not exported, create a simple test version.
  </action>
  <verify>cd mobile && flutter analyze test/fixtures/api_responses.dart test/fixtures/drive_scenarios.dart shows no errors</verify>
  <done>ApiResponses contains all webhook response patterns, DriveScenarios contains pre-built GPS sequences</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd mobile && flutter analyze` passes with no errors
- [ ] MockApiService extends Mock implements ApiService
- [ ] FakeBluetoothService has simulateConnect/simulateDisconnect
- [ ] FakeBackgroundService has simulate* methods for all callbacks
- [ ] ApiResponses has fixtures for: driving, parked, no_car_driving, api_error, gps_only, skip_paused
- [ ] DriveScenarios has: homeToOffice, tooShortTrip, tripWithSkipLocation, stationaryTrip, tripWithTraffic
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Mock services ready for use in integration tests
- Fixtures cover all stress test scenarios from ROADMAP.md
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure-mocks/01-02-SUMMARY.md`
</output>

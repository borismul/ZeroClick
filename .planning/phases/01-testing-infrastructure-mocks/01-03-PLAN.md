---
phase: 01-testing-infrastructure-mocks
plan: 03
type: execute
depends_on: []
files_modified:
  - api/pyproject.toml
  - api/tests/__init__.py
  - api/tests/conftest.py
  - api/tests/mocks/__init__.py
  - api/tests/mocks/mock_firestore.py
  - api/tests/mocks/mock_car_provider.py
domain: python
---

<objective>
Establish Python API test infrastructure with pytest, Firestore mocks, and car provider mocks.

Purpose: Create the testing foundation for the API backend so we can unit test the webhook state machine without real Firestore or car API calls.

Output: pytest configured, test directory structure, MockFirestore for trip cache, MockCarProvider for car API simulation.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-testing-infrastructure-mocks/1-RESEARCH.md

**Key files to reference:**
@api/pyproject.toml
@api/database.py
@api/services/webhook_service.py
@api/services/car_service.py
@api/car_providers/base.py

**From research:**
- No pytest in dev dependencies yet
- Trip cache stored at: users/{user_id}/cache/trip_start
- CarProvider base class has: connect(), disconnect(), get_data(), get_odometer()
- webhook_service uses: get_trip_cache(), save_trip_cache(), delete_trip_cache()

**Key counters to test (from API exploration):**
- no_driving_count: incremented when find_driving_car returns None
- parked_count: incremented when car API reports parked
- api_error_count: incremented when car API call fails
- skip_pause_count: incremented when parked at skip location
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pytest and test dependencies to pyproject.toml</name>
  <files>api/pyproject.toml</files>
  <action>
Add pytest and related testing packages to the dev dependencies in pyproject.toml:

Find the `[project.optional-dependencies]` section (or `[tool.uv]` dev section) and add:

```toml
[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-asyncio>=0.23.0",
    "pytest-cov>=4.1.0",
]
```

If there's already a dev section, append these packages to it.

Also add pytest configuration:

```toml
[tool.pytest.ini_options]
testpaths = ["tests"]
asyncio_mode = "auto"
python_files = ["test_*.py"]
python_functions = ["test_*"]
```

After editing, run `cd api && uv sync` to install the new dependencies.
  </action>
  <verify>cd api && uv sync && uv run pytest --version shows pytest installed</verify>
  <done>pytest>=8.0.0, pytest-asyncio, pytest-cov in dev dependencies and uv synced</done>
</task>

<task type="auto">
  <name>Task 2: Create test directory structure and conftest.py</name>
  <files>api/tests/__init__.py, api/tests/conftest.py, api/tests/mocks/__init__.py, api/tests/unit/__init__.py</files>
  <action>
Create the test directory structure:

```
api/tests/
├── __init__.py
├── conftest.py           # pytest fixtures
├── mocks/
│   ├── __init__.py
│   ├── mock_firestore.py
│   └── mock_car_provider.py
└── unit/
    └── __init__.py
```

**api/tests/__init__.py:** Empty file

**api/tests/conftest.py:**
```python
"""Pytest fixtures for API tests."""

import pytest
from unittest.mock import Mock, patch
from tests.mocks.mock_firestore import MockFirestore
from tests.mocks.mock_car_provider import MockCarProvider


@pytest.fixture
def mock_db():
    """Provide a mock Firestore database."""
    return MockFirestore()


@pytest.fixture
def mock_car_provider():
    """Provide a mock car provider."""
    return MockCarProvider()


@pytest.fixture
def sample_user_id():
    """Standard test user ID."""
    return "test@example.com"


@pytest.fixture
def sample_car_id():
    """Standard test car ID."""
    return "car-test-123"


@pytest.fixture
def sample_trip_cache():
    """Sample trip cache for testing."""
    return {
        "active": True,
        "user_id": "test@example.com",
        "car_id": "car-test-123",
        "car_name": "Test Car",
        "start_time": "2024-01-19T10:00:00Z",
        "start_odo": None,
        "last_odo": None,
        "no_driving_count": 0,
        "parked_count": 0,
        "api_error_count": 0,
        "skip_pause_count": 0,
        "gps_events": [],
        "gps_trail": [],
        "gps_only_mode": False,
        "end_triggered": None,
    }
```

**api/tests/mocks/__init__.py:**
```python
"""Mock implementations for testing."""

from .mock_firestore import MockFirestore
from .mock_car_provider import MockCarProvider

__all__ = ["MockFirestore", "MockCarProvider"]
```

**api/tests/unit/__init__.py:** Empty file
  </action>
  <verify>ls -la api/tests/ shows conftest.py, mocks/, unit/ directories</verify>
  <done>Test directory structure created with conftest.py containing base fixtures</done>
</task>

<task type="auto">
  <name>Task 3: Create MockFirestore for trip cache operations</name>
  <files>api/tests/mocks/mock_firestore.py</files>
  <action>
Create a mock Firestore client that simulates trip cache operations:

```python
"""Mock Firestore client for testing."""

from typing import Any
from datetime import datetime


class MockDocumentSnapshot:
    """Mock Firestore document snapshot."""

    def __init__(self, data: dict | None, doc_id: str = "trip_start"):
        self._data = data
        self.id = doc_id

    @property
    def exists(self) -> bool:
        return self._data is not None

    def to_dict(self) -> dict | None:
        return self._data


class MockDocumentReference:
    """Mock Firestore document reference."""

    def __init__(self, storage: dict, path: str):
        self._storage = storage
        self._path = path

    def get(self) -> MockDocumentSnapshot:
        data = self._storage.get(self._path)
        return MockDocumentSnapshot(data, self._path.split("/")[-1])

    def set(self, data: dict, merge: bool = False) -> None:
        if merge and self._path in self._storage:
            self._storage[self._path] = {**self._storage[self._path], **data}
        else:
            self._storage[self._path] = data

    def update(self, data: dict) -> None:
        if self._path in self._storage:
            self._storage[self._path].update(data)
        else:
            self._storage[self._path] = data

    def delete(self) -> None:
        if self._path in self._storage:
            del self._storage[self._path]


class MockCollectionReference:
    """Mock Firestore collection reference."""

    def __init__(self, storage: dict, path: str):
        self._storage = storage
        self._path = path

    def document(self, doc_id: str) -> MockDocumentReference:
        return MockDocumentReference(self._storage, f"{self._path}/{doc_id}")

    def add(self, data: dict) -> tuple[Any, MockDocumentReference]:
        doc_id = f"auto-{datetime.now().timestamp()}"
        doc_ref = self.document(doc_id)
        doc_ref.set(data)
        return None, doc_ref

    def stream(self):
        """Yield documents in this collection."""
        prefix = self._path + "/"
        for path, data in self._storage.items():
            if path.startswith(prefix) and path.count("/") == prefix.count("/"):
                doc_id = path.split("/")[-1]
                yield MockDocumentSnapshot(data, doc_id)


class MockFirestore:
    """Mock Firestore client for testing trip cache operations."""

    def __init__(self):
        self._storage: dict[str, dict] = {}

    def collection(self, name: str) -> MockCollectionReference:
        return MockCollectionReference(self._storage, name)

    # === Test Helper Methods ===

    def set_trip_cache(self, user_id: str, cache: dict) -> None:
        """Directly set trip cache for testing."""
        path = f"users/{user_id}/cache/trip_start"
        self._storage[path] = cache

    def get_trip_cache(self, user_id: str) -> dict | None:
        """Directly get trip cache for verification."""
        path = f"users/{user_id}/cache/trip_start"
        return self._storage.get(path)

    def clear_trip_cache(self, user_id: str) -> None:
        """Clear trip cache."""
        path = f"users/{user_id}/cache/trip_start"
        if path in self._storage:
            del self._storage[path]

    def set_car_credentials(self, user_id: str, car_id: str, credentials: dict) -> None:
        """Set car credentials for testing."""
        path = f"users/{user_id}/cars/{car_id}/credentials/api"
        self._storage[path] = credentials

    def reset(self) -> None:
        """Clear all stored data."""
        self._storage.clear()

    def dump(self) -> dict:
        """Return all stored data for debugging."""
        return dict(self._storage)
```

This mock provides:
- Document get/set/update/delete operations
- Collection document() and stream() operations
- Test helpers for direct cache manipulation
- Path-based storage matching Firestore structure
  </action>
  <verify>cd api && uv run python -c "from tests.mocks.mock_firestore import MockFirestore; db = MockFirestore(); print('OK')"</verify>
  <done>MockFirestore implements document/collection operations with test helpers for trip cache</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd api && uv sync` succeeds
- [ ] `cd api && uv run pytest --version` shows pytest 8.x
- [ ] `cd api && uv run python -c "from tests.mocks import MockFirestore, MockCarProvider"` succeeds
- [ ] MockFirestore has set_trip_cache, get_trip_cache, clear_trip_cache helpers
- [ ] Test directory structure matches expected layout
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- pytest configured and runnable
- MockFirestore ready for webhook service unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure-mocks/01-03-SUMMARY.md`
</output>

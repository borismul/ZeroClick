---
phase: 01-testing-infrastructure-mocks
plan: 01
type: execute
depends_on: []
files_modified:
  - mobile/test/mocks/mock_api_service.dart
  - mobile/test/mocks/fake_location_service.dart
  - mobile/test/fixtures/api_responses.dart
  - mobile/lib/services/location_service.dart
domain: flutter
---

<objective>
Establish Flutter test foundation with directory structure, abstract interfaces, and core mock implementations.

Purpose: Create the testing infrastructure that all subsequent test plans depend on. Without mockable service interfaces, we cannot write meaningful unit or integration tests.

Output: Test directory structure, `LocationServiceInterface` abstraction, `FakeLocationService` for drive simulation, `MockApiService` for webhook testing.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-testing-infrastructure-mocks/1-RESEARCH.md

**Key files to reference:**
@mobile/lib/services/location_service.dart
@mobile/lib/services/api_service.dart
@mobile/pubspec.yaml
@mobile/test/widget_test.dart

**From research:**
- mocktail ^1.0.4 already in pubspec.yaml dev_dependencies
- LocationService uses static Geolocator methods - need wrapper
- ApiService has webhook methods: startTrip, endTrip, sendPing, finalize, cancel, getStatus
- Use FakeAsync pattern for time-based testing (ping intervals, timeouts)

**Architecture patterns from research:**
- Abstract interface + mock implementation pattern
- FakeLocationService with scheduleDrive() and triggerNextPing() for simulation
- MockApiService extends Mock implements ApiService
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test directory structure</name>
  <files>mobile/test/mocks/.gitkeep, mobile/test/unit/.gitkeep, mobile/test/fixtures/.gitkeep, mobile/test/integration/.gitkeep</files>
  <action>
Create the test directory structure for organized test files:
```
mobile/test/
├── mocks/           # Mock service implementations
├── unit/            # Unit tests for services
├── fixtures/        # Test data and scenarios
├── integration/     # Integration tests (drive simulation)
└── widget_test.dart # Existing (keep as-is)
```

Create empty .gitkeep files in each directory to ensure git tracks them. Do NOT modify the existing widget_test.dart.
  </action>
  <verify>ls -la mobile/test/ shows mocks/, unit/, fixtures/, integration/ directories</verify>
  <done>Four test subdirectories exist with .gitkeep files</done>
</task>

<task type="auto">
  <name>Task 2: Create LocationServiceInterface and refactor LocationService</name>
  <files>mobile/lib/services/location_service.dart</files>
  <action>
Add an abstract interface to location_service.dart that mirrors the public API:

```dart
/// Abstract interface for location services - enables testing with mocks
abstract class LocationServiceInterface {
  Future<bool> requestPermissions();
  Future<bool> get hasPermission;
  Future<LocationResult?> getCurrentLocation();
  Future<LocationResult?> getLastKnownLocation();
  Future<bool> isLocationEnabled();
  Future<bool> startBackgroundTracking({
    required void Function(LocationResult) onLocationUpdate,
    Duration pingInterval,
  });
  void stopBackgroundTracking();
  bool get isTracking;
  String? get lastError;
}
```

Make the existing `LocationService` class implement this interface:
`class LocationService implements LocationServiceInterface`

This is a non-breaking change - existing code continues to work, but now we can create mock implementations.

Do NOT change any method implementations, only add the interface and implements clause.
  </action>
  <verify>cd mobile && flutter analyze lib/services/location_service.dart shows no errors</verify>
  <done>LocationServiceInterface exists, LocationService implements it, no breaking changes</done>
</task>

<task type="auto">
  <name>Task 3: Create FakeLocationService for drive simulation</name>
  <files>mobile/test/mocks/fake_location_service.dart</files>
  <action>
Create a fake implementation that allows tests to control GPS locations:

```dart
import 'package:mileage_tracker/services/location_service.dart';

/// Fake location service for testing - allows scheduling GPS locations
/// and triggering pings manually for drive simulation.
class FakeLocationService implements LocationServiceInterface {
  final List<LocationResult> _scheduledLocations = [];
  void Function(LocationResult)? _onLocationUpdate;
  bool _isTracking = false;
  int _currentIndex = 0;
  String? _lastError;
  bool _hasPermission = true;
  bool _locationEnabled = true;

  // === Test Setup Methods ===

  /// Queue a sequence of locations for a simulated drive
  void scheduleDrive(List<LocationResult> locations) {
    _scheduledLocations.addAll(locations);
  }

  /// Clear scheduled locations and reset state
  void reset() {
    _scheduledLocations.clear();
    _currentIndex = 0;
    _isTracking = false;
    _onLocationUpdate = null;
    _lastError = null;
  }

  /// Simulate the next ping being triggered (called by test/FakeAsync)
  void triggerNextPing() {
    if (_currentIndex < _scheduledLocations.length && _onLocationUpdate != null) {
      _onLocationUpdate!(_scheduledLocations[_currentIndex++]);
    }
  }

  /// Set whether permissions are granted (for permission testing)
  void setHasPermission(bool value) => _hasPermission = value;

  /// Set whether location services are enabled
  void setLocationEnabled(bool value) => _locationEnabled = value;

  /// Simulate an error occurring
  void simulateError(String error) => _lastError = error;

  // === LocationServiceInterface Implementation ===

  @override
  Future<bool> requestPermissions() async => _hasPermission;

  @override
  Future<bool> get hasPermission async => _hasPermission;

  @override
  Future<LocationResult?> getCurrentLocation() async {
    if (_currentIndex < _scheduledLocations.length) {
      return _scheduledLocations[_currentIndex];
    }
    return null;
  }

  @override
  Future<LocationResult?> getLastKnownLocation() async {
    if (_currentIndex > 0 && _currentIndex <= _scheduledLocations.length) {
      return _scheduledLocations[_currentIndex - 1];
    }
    return null;
  }

  @override
  Future<bool> isLocationEnabled() async => _locationEnabled;

  @override
  Future<bool> startBackgroundTracking({
    required void Function(LocationResult) onLocationUpdate,
    Duration pingInterval = const Duration(minutes: 1),
  }) async {
    _onLocationUpdate = onLocationUpdate;
    _isTracking = true;
    return true;
  }

  @override
  void stopBackgroundTracking() {
    _isTracking = false;
    _onLocationUpdate = null;
  }

  @override
  bool get isTracking => _isTracking;

  @override
  String? get lastError => _lastError;
}
```

Import the location_service.dart to get LocationResult and LocationServiceInterface.
  </action>
  <verify>cd mobile && flutter analyze test/mocks/fake_location_service.dart shows no errors</verify>
  <done>FakeLocationService implements LocationServiceInterface with scheduleDrive(), triggerNextPing(), and test helpers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd mobile && flutter analyze` passes with no errors
- [ ] Test directories exist: mocks/, unit/, fixtures/, integration/
- [ ] LocationServiceInterface is defined in location_service.dart
- [ ] LocationService implements LocationServiceInterface
- [ ] FakeLocationService compiles and implements all interface methods
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No breaking changes to existing code
- Foundation ready for Plan 02 (mock expansion) and Plan 05 (drive simulation)
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure-mocks/01-01-SUMMARY.md`
</output>

---
phase: 01-testing-infrastructure-mocks
plan: 05
type: execute
depends_on: ["01-01", "01-02"]
files_modified:
  - mobile/test/integration/drive_simulator.dart
  - mobile/test/integration/trip_lifecycle_test.dart
domain: flutter
---

<objective>
Create DriveSimulator class and integration tests for complete trip lifecycle using FakeAsync.

Purpose: Enable testing of full trip scenarios (start → pings → finalize) with controlled time, simulated GPS, and mock API responses.

Output: DriveSimulator that orchestrates mock services, integration test proving trip lifecycle works end-to-end.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-testing-infrastructure-mocks/1-RESEARCH.md
@.planning/phases/01-testing-infrastructure-mocks/01-01-SUMMARY.md
@.planning/phases/01-testing-infrastructure-mocks/01-02-SUMMARY.md

**Key files to reference:**
@mobile/test/mocks/fake_location_service.dart
@mobile/test/mocks/mock_api_service.dart
@mobile/test/mocks/mock_bluetooth_service.dart
@mobile/test/fixtures/drive_scenarios.dart
@mobile/test/fixtures/api_responses.dart

**From research - FakeAsync pattern:**
```dart
fakeAsync((async) {
  // Setup mocks
  // Trigger actions
  async.elapse(Duration(minutes: 1)); // Advance time
  // Verify results
});
```

**Trip lifecycle from AppDelegate/BackgroundService:**
1. Motion detected (automotive) → startTrip called
2. First ping after 2 seconds → car detection
3. Pings every 60 seconds → accumulate GPS
4. Motion stationary/parked → endTrip called
5. Backend finalizes with odometer delta or GPS distance
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DriveSimulator orchestration class</name>
  <files>mobile/test/integration/drive_simulator.dart</files>
  <action>
Create a test utility that orchestrates all mock services for drive simulation:

```dart
import 'package:fake_async/fake_async.dart';
import 'package:mocktail/mocktail.dart';
import 'package:mileage_tracker/services/location_service.dart';
import '../mocks/fake_location_service.dart';
import '../mocks/mock_api_service.dart';
import '../mocks/mock_bluetooth_service.dart';
import '../mocks/mock_background_service.dart';
import '../fixtures/api_responses.dart';
import '../fixtures/drive_scenarios.dart';

/// Orchestrates mock services for drive simulation testing.
///
/// Usage:
/// ```dart
/// fakeAsync((async) {
///   final simulator = DriveSimulator();
///   simulator.setupHomeToOfficeTrip();
///   simulator.startTrip();
///
///   for (var i = 0; i < 5; i++) {
///     async.elapse(Duration(minutes: 1));
///     simulator.triggerPing();
///   }
///
///   simulator.endTrip();
///   expect(simulator.wasTripFinalized, isTrue);
/// });
/// ```
class DriveSimulator {
  final FakeLocationService locationService;
  final MockApiService apiService;
  final FakeBluetoothService bluetoothService;
  final FakeBackgroundService backgroundService;

  // Trip state tracking
  bool _tripStarted = false;
  bool _tripFinalized = false;
  bool _tripCancelled = false;
  int _pingCount = 0;
  final List<Map<String, dynamic>> _pingResponses = [];

  DriveSimulator({
    FakeLocationService? location,
    MockApiService? api,
    FakeBluetoothService? bluetooth,
    FakeBackgroundService? background,
  })  : locationService = location ?? FakeLocationService(),
        apiService = api ?? MockApiService(),
        bluetoothService = bluetooth ?? FakeBluetoothService(),
        backgroundService = background ?? FakeBackgroundService();

  // === Setup Methods ===

  /// Configure a simple home-to-office drive scenario
  void setupHomeToOfficeTrip({String? bluetoothDevice}) {
    locationService.scheduleDrive(DriveScenarios.homeToOffice());

    if (bluetoothDevice != null) {
      bluetoothService.simulateConnect(bluetoothDevice);
    }

    _setupDefaultApiResponses();
  }

  /// Configure a trip that visits a skip location
  void setupTripWithSkipLocation({String? bluetoothDevice}) {
    locationService.scheduleDrive(DriveScenarios.tripWithSkipLocation());

    if (bluetoothDevice != null) {
      bluetoothService.simulateConnect(bluetoothDevice);
    }

    _setupDefaultApiResponses();
  }

  /// Configure a stationary trip (should be cancelled)
  void setupStationaryTrip() {
    locationService.scheduleDrive(DriveScenarios.stationaryTrip());
    _setupNoDrivingApiResponses();
  }

  /// Configure API to fail (for GPS-only mode testing)
  void setupApiFailures() {
    when(() => apiService.sendPing(any(), any(), deviceId: any(named: 'deviceId')))
        .thenThrow(ApiResponses.serverError502());
  }

  /// Configure custom API response sequence
  void setupApiResponseSequence(List<Map<String, dynamic>> responses) {
    var index = 0;
    when(() => apiService.sendPing(any(), any(), deviceId: any(named: 'deviceId')))
        .thenAnswer((_) async {
      if (index < responses.length) {
        return responses[index++];
      }
      return ApiResponses.drivingResponse();
    });
  }

  void _setupDefaultApiResponses() {
    // First ping: car identified, driving
    // Subsequent pings: driving with increasing distance
    var pingNum = 0;
    when(() => apiService.sendPing(any(), any(), deviceId: any(named: 'deviceId')))
        .thenAnswer((_) async {
      pingNum++;
      return ApiResponses.drivingResponse(distanceKm: pingNum * 3.0);
    });

    when(() => apiService.startTrip(any(), any(), deviceId: any(named: 'deviceId')))
        .thenAnswer((_) async => ApiResponses.tripStartedResponse());

    when(() => apiService.endTrip(any(), any()))
        .thenAnswer((_) async => ApiResponses.tripFinalizedResponse(totalKm: 15.0));

    when(() => apiService.finalize())
        .thenAnswer((_) async => ApiResponses.tripFinalizedResponse(totalKm: 15.0));

    when(() => apiService.cancel())
        .thenAnswer((_) async => ApiResponses.tripCancelledResponse());
  }

  void _setupNoDrivingApiResponses() {
    var noDrivingCount = 0;
    when(() => apiService.sendPing(any(), any(), deviceId: any(named: 'deviceId')))
        .thenAnswer((_) async {
      noDrivingCount++;
      return ApiResponses.noCarDrivingResponse(noDrivingCount: noDrivingCount);
    });

    when(() => apiService.cancel())
        .thenAnswer((_) async {
      _tripCancelled = true;
      return ApiResponses.tripCancelledResponse();
    });
  }

  // === Trip Lifecycle Methods ===

  /// Start the trip (simulates motion detection trigger)
  Future<void> startTrip() async {
    _tripStarted = true;

    // Get first location
    final location = await locationService.getCurrentLocation();
    if (location != null) {
      await apiService.startTrip(
        location.lat,
        location.lng,
        deviceId: bluetoothService.connectedDevice,
      );
    }

    // Start background tracking
    await locationService.startBackgroundTracking(
      onLocationUpdate: (loc) {
        // This would be called by timer in real code
      },
    );
  }

  /// Trigger a ping (simulates 60-second timer firing)
  Future<Map<String, dynamic>> triggerPing() async {
    _pingCount++;
    locationService.triggerNextPing();

    final location = await locationService.getCurrentLocation();
    if (location == null) {
      return {'status': 'no_location'};
    }

    final response = await apiService.sendPing(
      location.lat,
      location.lng,
      deviceId: bluetoothService.connectedDevice,
    );

    _pingResponses.add(response);
    return response;
  }

  /// End the trip (simulates motion stationary or Bluetooth disconnect)
  Future<void> endTrip() async {
    locationService.stopBackgroundTracking();

    final location = await locationService.getLastKnownLocation();
    if (location != null) {
      final response = await apiService.endTrip(location.lat, location.lng);
      if (response['status'] == 'finalized') {
        _tripFinalized = true;
      }
    }
  }

  /// Force cancel the trip
  Future<void> cancelTrip() async {
    locationService.stopBackgroundTracking();
    await apiService.cancel();
    _tripCancelled = true;
  }

  // === State Accessors ===

  bool get isTripStarted => _tripStarted;
  bool get wasTripFinalized => _tripFinalized;
  bool get wasTripCancelled => _tripCancelled;
  int get pingCount => _pingCount;
  List<Map<String, dynamic>> get pingResponses => List.unmodifiable(_pingResponses);

  /// Get the last ping response
  Map<String, dynamic>? get lastPingResponse =>
      _pingResponses.isNotEmpty ? _pingResponses.last : null;

  /// Check if any ping returned a specific status
  bool hasStatusInResponses(String status) =>
      _pingResponses.any((r) => r['status'] == status);

  // === Verification Helpers ===

  /// Verify startTrip was called with expected coordinates
  void verifyTripStartedAt(double lat, double lng) {
    verify(() => apiService.startTrip(
      any(that: closeTo(lat, 0.001)),
      any(that: closeTo(lng, 0.001)),
      deviceId: any(named: 'deviceId'),
    )).called(1);
  }

  /// Verify a specific number of pings were sent
  void verifyPingCount(int expected) {
    verify(() => apiService.sendPing(
      any(),
      any(),
      deviceId: any(named: 'deviceId'),
    )).called(expected);
  }

  /// Reset all mock services for next test
  void reset() {
    locationService.reset();
    bluetoothService.reset();
    backgroundService.reset();
    _tripStarted = false;
    _tripFinalized = false;
    _tripCancelled = false;
    _pingCount = 0;
    _pingResponses.clear();
  }
}

/// Matcher for approximate double comparison
Matcher closeTo(double value, double delta) => _CloseToMatcher(value, delta);

class _CloseToMatcher extends Matcher {
  final double _value;
  final double _delta;

  _CloseToMatcher(this._value, this._delta);

  @override
  bool matches(item, Map matchState) =>
      item is double && (item - _value).abs() <= _delta;

  @override
  Description describe(Description description) =>
      description.add('a value within $_delta of $_value');
}
```

Note: This requires mocktail's `when`, `verify`, `any` functions. Import them.
  </action>
  <verify>cd mobile && flutter analyze test/integration/drive_simulator.dart shows no errors</verify>
  <done>DriveSimulator orchestrates mock services with setup methods for common scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Create integration test for full trip lifecycle</name>
  <files>mobile/test/integration/trip_lifecycle_test.dart</files>
  <action>
Create integration tests that verify complete trip scenarios:

```dart
import 'package:fake_async/fake_async.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import '../mocks/mock_api_service.dart';
import '../fixtures/api_responses.dart';
import 'drive_simulator.dart';

void main() {
  // Register fallback values for mocktail any() matchers
  setUpAll(() {
    registerFallbackValue(0.0);
    registerFallbackValue('');
  });

  group('Trip Lifecycle Integration Tests', () {
    late DriveSimulator simulator;
    late MockApiService mockApi;

    setUp(() {
      mockApi = MockApiService();
      simulator = DriveSimulator(api: mockApi);
    });

    tearDown(() {
      simulator.reset();
    });

    test('complete home-to-office trip finalizes successfully', () {
      fakeAsync((async) {
        // Arrange: setup home-to-office drive with Bluetooth car
        simulator.setupHomeToOfficeTrip(bluetoothDevice: 'Audi MMI 1234');

        // Act: start trip
        simulator.startTrip();
        expect(simulator.isTripStarted, isTrue);

        // Simulate 5 ping intervals (5 minutes of driving)
        for (var i = 0; i < 5; i++) {
          async.elapse(const Duration(minutes: 1));
          simulator.triggerPing();
        }

        // End trip (simulates motion becoming stationary)
        simulator.endTrip();

        // Assert: trip should be finalized
        expect(simulator.wasTripFinalized, isTrue);
        expect(simulator.pingCount, equals(5));
      });
    });

    test('trip with no driving car found cancels after 3 pings', () {
      fakeAsync((async) {
        // Arrange: setup stationary trip (no car movement detected)
        simulator.setupStationaryTrip();

        // Simulate API returning no_car_driving
        var noDrivingCount = 0;
        when(() => mockApi.sendPing(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async {
          noDrivingCount++;
          if (noDrivingCount >= 3) {
            // Trigger cancellation
            simulator.cancelTrip();
          }
          return ApiResponses.noCarDrivingResponse(noDrivingCount: noDrivingCount);
        });

        when(() => mockApi.startTrip(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async => ApiResponses.tripStartedResponse());

        when(() => mockApi.cancel())
            .thenAnswer((_) async => ApiResponses.tripCancelledResponse());

        // Act: start trip
        simulator.startTrip();

        // Simulate 3 pings - should trigger cancellation
        for (var i = 0; i < 3; i++) {
          async.elapse(const Duration(minutes: 1));
          simulator.triggerPing();
        }

        // Assert: trip should be cancelled
        expect(simulator.wasTripCancelled, isTrue);
        expect(simulator.pingCount, equals(3));
      });
    });

    test('trip finalizes after 3 parked pings', () {
      fakeAsync((async) {
        // Arrange: setup normal trip
        simulator.setupHomeToOfficeTrip(bluetoothDevice: 'Audi MMI 1234');

        // Configure: 3 driving pings, then 3 parked pings
        var pingNum = 0;
        when(() => mockApi.sendPing(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async {
          pingNum++;
          if (pingNum <= 3) {
            return ApiResponses.drivingResponse(distanceKm: pingNum * 3.0);
          } else {
            return ApiResponses.parkedResponse(
              parkedCount: pingNum - 3,
              distanceKm: 10.0,
            );
          }
        });

        when(() => mockApi.startTrip(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async => ApiResponses.tripStartedResponse());

        when(() => mockApi.finalize())
            .thenAnswer((_) async => ApiResponses.tripFinalizedResponse(totalKm: 10.0));

        // Act
        simulator.startTrip();

        // 3 driving pings
        for (var i = 0; i < 3; i++) {
          async.elapse(const Duration(minutes: 1));
          simulator.triggerPing();
        }

        // 3 parked pings - should trigger finalization
        for (var i = 0; i < 3; i++) {
          async.elapse(const Duration(minutes: 1));
          final response = simulator.triggerPing();

          // When parked_count reaches 3, finalize
          if ((response['parked_count'] ?? 0) >= 3) {
            simulator.endTrip();
            break;
          }
        }

        // Assert
        expect(simulator.pingCount, greaterThanOrEqualTo(5));
        expect(simulator.hasStatusInResponses('parked'), isTrue);
      });
    });

    test('Bluetooth device identifies car for trip', () {
      fakeAsync((async) {
        // Arrange: connect Bluetooth before trip
        simulator.bluetoothService.simulateConnect('Audi MMI 1234');
        simulator.setupHomeToOfficeTrip(bluetoothDevice: 'Audi MMI 1234');

        when(() => mockApi.startTrip(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async => ApiResponses.tripStartedResponse());

        // Act
        simulator.startTrip();

        // Assert: Bluetooth device should be passed to API
        verify(() => mockApi.startTrip(
          any(),
          any(),
          deviceId: 'Audi MMI 1234',
        )).called(1);
      });
    });

    test('trip continues without Bluetooth device', () {
      fakeAsync((async) {
        // Arrange: no Bluetooth
        simulator.setupHomeToOfficeTrip(); // No bluetoothDevice

        when(() => mockApi.startTrip(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async => ApiResponses.tripStartedResponse());

        // Act
        simulator.startTrip();

        // Assert: deviceId should be null
        verify(() => mockApi.startTrip(
          any(),
          any(),
          deviceId: null,
        )).called(1);
      });
    });
  });

  group('GPS-Only Mode Tests', () {
    late DriveSimulator simulator;
    late MockApiService mockApi;

    setUp(() {
      mockApi = MockApiService();
      simulator = DriveSimulator(api: mockApi);
    });

    tearDown(() {
      simulator.reset();
    });

    test('GPS-only mode activates after 2 API errors', () {
      fakeAsync((async) {
        // Arrange
        simulator.setupHomeToOfficeTrip();

        var apiErrorCount = 0;
        when(() => mockApi.sendPing(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async {
          apiErrorCount++;
          if (apiErrorCount <= 2) {
            return ApiResponses.apiErrorResponse(apiErrorCount: apiErrorCount);
          }
          // After 2 errors, switch to GPS-only
          return ApiResponses.gpsOnlyResponse(distanceKm: 5.0);
        });

        when(() => mockApi.startTrip(any(), any(), deviceId: any(named: 'deviceId')))
            .thenAnswer((_) async => ApiResponses.tripStartedResponse());

        // Act
        simulator.startTrip();

        // First 2 pings should report API errors
        for (var i = 0; i < 2; i++) {
          async.elapse(const Duration(minutes: 1));
          final response = simulator.triggerPing();
          expect(response['status'], equals('api_error'));
        }

        // Third ping should be in GPS-only mode
        async.elapse(const Duration(minutes: 1));
        final gpsResponse = simulator.triggerPing();
        expect(gpsResponse['status'], equals('gps_only'));
        expect(gpsResponse['gps_only_mode'], isTrue);
      });
    });
  });
}
```

These tests use FakeAsync to control time and verify trip lifecycle without real delays.
  </action>
  <verify>cd mobile && flutter test test/integration/trip_lifecycle_test.dart shows all tests passing</verify>
  <done>Integration tests verify complete trip lifecycle with FakeAsync time control</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd mobile && flutter analyze test/integration/` shows no errors
- [ ] `cd mobile && flutter test test/integration/` shows all tests passing
- [ ] DriveSimulator can orchestrate: location, API, Bluetooth, background services
- [ ] Tests cover: normal trip, no-car cancellation, parked finalization, Bluetooth identification
- [ ] GPS-only mode activation test passes
</verification>

<success_criteria>
- All tasks completed
- All tests pass
- DriveSimulator provides clean testing interface
- Trip lifecycle fully testable with controlled time
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure-mocks/01-05-SUMMARY.md`
</output>
